<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>ToupCam API 手册</title>
</head>
<body>
<h1 align="center">ToupCam API 手册</h1>
<p>&nbsp;</p>
<hr/>
<h1><font color="#0000FF">1. 版本</font></h1>
<hr/>
<blockquote>
  <p>1.6.5660.20150520</p>
</blockquote>
<hr/>
<h1><font color="#0000FF">2. 简介</font></h1><hr/>
<p align="left">ToupCam系列相机（包含UCMOS, WCMOS, LCMOS, U3CMOS, L3CMOS, E3CMOS, ICMOS, GCMOS, UHCCD, EXCCD, SCCCD等型号系列）支持多种API，包括：Native C/C++，.NET/C#/VB.NET, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd375454(v=vs.85).aspx">DirectShow</a>, <a href="http://twain.org/">Twain</a>, LabView等等. Native C/C++ API作为底层(Low Level) API相比较其他API的特点是使用纯C/C++开发，不依赖其他的运行时库，接口简洁，控制灵活. 本SDK压缩包包含了所有需要用到的的资源和信息, 目录如下:</p>
<ul>
  <li>inc</li>
</ul>
<blockquote> 
  <p>toupcam.h, C/C++ 头文件<br/></p>
    toupcam.cs, 支持C#. toupcam.cs使用P/Invoke调用至toupcam.dll. 请把toupcam.cs 拷贝到你的C#工程中使用.<br/>
    toupcam.vb, 支持VB.NET. toupcam.vb使用P/Invoke调用至toupcam.dll. 请把toupcam.vb 拷贝到你的VB.NET工程中使用.<br/>
</blockquote>
<ul>
  <li>win: Microsoft Windows平台文件
    <ul>
      <li>inc
        <blockquote>
          <p align="left">toupcam.cs, 支持C#. toupcam.cs使用P/Invoke调用至toupcam.dll. 请把toupcam.cs 拷贝到你的C#工程中使用.<br/>
    toupcam.vb, 支持VB.NET. toupcam.vb使用P/Invoke调用至toupcam.dll. 请把toupcam.vb 拷贝到你的VB.NET工程中使用.<br/>
       </p></blockquote>
      </li>
      <li>x86
        <blockquote>
          <p align="left">toupcam.lib, x86 lib 文件.<br/>
            toupcam.dll, x86 动态库文件.<br/>
            toupcamdemocpp.exe, x86 C++ demo执行程序.</p>
        </blockquote>
      </li>
    <li>x64
      <blockquote>
        <p align="left">toupcam.lib, x64 lib文件.<br/>
          toupcam.dll, x64 动态库文件.<br/>
          toupcamdemocpp.exe,  x64 C++ demo 执行程序.</p>
      </blockquote>
    </li>
    <li>drivers
      <blockquote>
        <p align="left">x86 文件夹包含x86的内核态驱动文件,包括toupcam.cat,  toupcam.inf 和 toupcam.sys.<br/>
          x64 文件夹包含x64的内核态驱动文件,包括toupcam.cat, toupcam.inf 和 toupcam.sys.</p>
      </blockquote>
    </li>
    <li>samples
      <blockquote>
        <p>a). toupcamdemocpp, C++例子.本例子演示了枚举设备，打开设备，预览视频，抓拍图像，设置分辨率, 多种图片格式(.bmp, .jpg, .png等)保存图像到文件，wmv格式录像等等.这个例子使用了Pull Mode机制. 为了保持代码整洁, 例子使用的WTL库可以从这个链接下载<a href="http://sourceforge.net/projects/wtl/">http://sourceforge.net/projects/wtl/</a> <br/>
          b). toupcamdemomfc, 一个简单C++例子，使用MFC作为GUI库，支持打开设备，预览视频，抓拍图像, 设置分辨率, 多种图片格式(.bmp, .jpg, .png等)保存图像到文件,等等.这个例子使用了Pull Mode机制.<br/>
          c). toupcamdemowinformcs1, C# winform例子，支持打开设备，预览视频，抓拍图像，保存图片到文件，设置白平衡. 这个例子使用了Pull Mode机制, StartPullModeWithWndMsg.<br/>
          d). toupcamdemowinformcs2, C# winform例子，支持打开设备，预览视频，抓拍图像，保存图片到文件，设置白平衡. 这个例子使用了Pull Mode机制, StartPullModeWithCallback.<br/>
          e). toupcamdemowinformvb, VB.NET winform例子，支持打开设备，预览视频，抓拍图像，保存图片到文件，设置白平衡. 这个例子使用了Pull Mode机制.</p>
      </blockquote>
    </li>
    <li>extras
      <blockquote>
        <p align="left">a). directshow: DirectShow SDK和demo程序<br/>
          b). twain: TWAIN SDK和demo程序<br/>
          c). labview: Labview SDK和demo程序</p>
      </blockquote>
    </li>
    </ul>
  </li>
</ul>
 <ul><li>linux: Linux平台文件
 	<ul>
 	<li>udev: 99-toupcam.rules, udev rule文件. 请参考: <a href="http://reactivated.net/writing_udev_rules.html">http://reactivated.net/writing_udev_rules.html</a></li>
     <li>inc: toupcam.cs, for Mono C#. toupcam.cs使用P/Invoke调用至libtoupcam.so. 请把toupcam.cs 拷贝到你的C#工程中使用.</li>
     <li>x86: libtoupcam.so, x86版本so文件.</li>
     <li>x64: libtoupcam.so, x64版本so文件.</li>
	</ul>
 	</li></ul>
<ul><li>osx: MAC OSX平台文件.</li></ul>
<ul><li>doc: 包含中英文SDK使用文档.</li></ul>
<hr/>
<h1><font color="#0000FF">3. 概念和术语</font></h1>
<hr/>
<h2><font color="#0000FF">a. 获取图像数据的模式: “Pull Mode” vs “Push Mode” (“拉”模式 vs “推”模式)</font></h2>
<p>Toupcam提供了两种模式来获取图像数据: Pull Mode 和 Push Mode. 推荐使用前者，因为它更简单,且在多线程情况下更加不容易出错, 尤其是使用windows消息机制的情况下.</p>
<ul>
  <li>Pull Mode, toupcam 扮演被动角色，应用程序从toupcam“拉”图像数据. toupcam内部线程从相机获得图像数据,并保存到内部缓存中, 然后通知应用程序来取图像数据. 应用程序可以调用 Toupcam_PullImage和Toupcam_PullStillImage来获取图像数据. 存在两种方式来通知应用程序:
    <blockquote>a) 使用Windows消息机制: 通过调用函数 Toupcam_StartPullModeWithWndMsg启动Pull mode模式. 当事件发生时, toupcam会主动发送消息(PostMessage)到指定窗口. 参数WPARAM 是事件类型, 请参考TOUPCAM_EVENT_xxxx的定义. 参数LPARAM保留位使用. 本模式规避了多线程问题，是最简单的方式.(显然，这种方式只支持Windows系统，不支持Linux和MacOSX.)</blockquote>
    <blockquote>b) 使用回调函数使用 Toupcam_StartPullModeWithCallback启动Pull mode模式. 当事件发生时, 会调用PTOUPCAM_EVENT_CALLBACK回调函数（请注意这个回掉函数是在toupcam.dll内部线程上下文中执行的，所以不要在回调函数上上下文中调用Toupcam_Stop和Toupcam_Close，否则会死锁）.</blockquote>
  </li>
</ul>
<blockquote>
  <p>在Pull Mode 情况下, toupcam不但可以通知应用程序图像数据或者静态图片到达，还可以通知其他事件类型，如下所示:</p>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_EXPOSURE</td>
        <td width="72%" valign="top">曝光时间发生改变</td>
      </tr>
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_TEMPTINT</td>
        <td width="72%" valign="top">白平衡参数发生改变,Temp/Tint模式, 请参阅<a href="#wb">这里</a>.</td>
      </tr>
      <tr>
        <td valign="top">TOUPCAM_EVENT_WBGAIN</td>
        <td valign="top">白平衡参数发生改变,RGB Gain模式, 请参阅<a href="#wb">这里</a>.</td>
      </tr>
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_IMAGE</td>
        <td width="72%" valign="top">视频图像数据到达(视频).使用Toupcam_PullImage“拉”图像数据</td>
      </tr>
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_STILLIMAGE</td>
        <td width="72%" valign="top">静态图片数据到达(Toupcam_Snap引发).使用Toupcam_PullStillImage“拉”图像数据</td>
      </tr>
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_ERROR</td>
        <td width="72%" valign="top">发生错误，数据采集不能继续</td>
      </tr>
      <tr>
        <td width="28%" valign="top">TOUPCAM_EVENT_DISCONNECTED</td>
        <td width="72%" valign="top">相机断开连接，如被拔出</td>
      </tr>	  
    </table>
  </div>
</blockquote>
<ul>
  <li>Push Mode情况下, toupcam作为主动方，一旦内部底层线程从camera中抓取到图像数据，就通过PTOUPCAM_DATA_CALLBACK把图像数据“推”给应用程序 (请注意这个回调函数是在toupcam.dll内部线程上下文中执行的). 调用Toupcam_StartPushMode函数进入推模式.推模式比较复杂，有一些特别注意事项（如多线程问题，也不能在PTOUPCAM_DATA_CALLBACK回调函数里面调用Toupcam_Close和Toupcam_Stop等等）.</li>
</ul>
<h2><font color="#0000FF">b. 静态抓拍(静态图片, Still Image)</font></h2>
<p>大部分的相机型号都支持所谓静态抓拍的能力，指相机在连续的视频预览过程中，临时切换到另外一个分辨率，抓取一帧静态图片之后，马上把分辨率切换回原始分辨率的过程.</p>
<p>举例来说，UCMOS05100KPA支持3种分辨率，当前视频预览分辨率为1280 * 960, 调用函数Toupcam_Snap(h, 0)静态抓拍分辨率2592 * 1944的静态图片，这时相机临时切换到2592 * 1944的分辨率，抓取一帧数据之后，又把分辨率切换成原来的1280 * 960.</p>
<blockquote>a) 拉模式下，抓拍到静态图片之后，通知外层应用TOUPCAM_EVENT_STILLIMAGE事件, 然后外层应用调用Toupcam_PullStillImage获取静态图片的数据.</blockquote>
<blockquote>b) 推模式下，抓拍到静态图片之后，回调函数PTOUPCAM_DATA_CALLBACK, 参数bSnap设置为TRUE，图片的分辨率等信息在参数pHeader中.</blockquote>
<p>可以通过函数Toupcam_get_StillResolutionNumber的返回值或者结构ToupcamModel的still值来查看是否支持静态抓拍能力.</p>
<h2><font color="#0000FF"><a id="raw">c. 数据格式: RGB vs RAW</a></font></h2>
<p>Toupcam支持两种数据格式: RGB格式(默认)和RAW格式. RAW模式可以通过调用函数Toupcam_put_Option设置参数TOUPCAM_OPTION_RAW为1开启.</p>
<ul><li>RGB格式: 本模式下，获取底层传感器的数据之后，进行内部的颜色处理，输出结果中每像素包含3字节分别代表R/G/B值.</li></ul>
<ul><li>RAW格式: 本模式下, 直接获取底层传感器的“裸”数据，不进行内部颜色处理. 具体的RAW格式可以调用函数Toupcam_get_RawFormat获取. RAW格式模式下, 有关颜色处理的功能(如白平衡)和函数（如Toupcam_put_Hue,Toupcam_AwbOnePush等等）都无意义.</li></ul>
<p>用户可以通过TOUPCAM_OPTION_RAW调用函数Toupcam_put_Option来切换这两种模式.请注意切换模式必须在调用相机开启函数(Toupcam_StartPullModeWithWndMsg或Toupcam_StartPullModeWithCallback或Toupcam_StartPushMode)之前.</p>
<h2><font color="#0000FF"><a id="wb">d. 白平衡和自动白平衡: Temp/Tint模式 vs RGB Gain模式</a></font></h2>
<p>1. Toupcam支持互相独立的两种模式描述白平衡: a) Temp/Tint模式; b) RGB Gain模式</p>
<blockquote>
<p>a) 默认是Temp/Tint模式，在本模式下，使用Temp, Tint这2个参数来控制白平衡. Toupcam_get_TempTint获取值，Toupcam_put_TempTint设置值. Toupcam_AwbOnePush执行自动白平衡. 当白平衡参数改变时，发送TOUPCAM_EVENT_TEMPTINT通知消息.</p>
<p>b) 在RGB Gain模式下，使用3个通道的Gain值来控制白平衡. Toupcam_get_WhiteBalanceGain获取值，Toupcam_put_WhiteBalanceGain设置值. Toupcam_AwbInit执行自动白平衡. 当白平衡参数改变时，发送TOUPCAM_EVENT_WBGAIN通知消息.</p>
<p>两种模式下使用的函数不能混淆:</p>
	<blockquote>
	a) Temp/Tint模式下，必须使用Toupcam_get_TempTint和Toupcam_put_TempTint和Toupcam_AwbOnePush. 而Toupcam_get_WhiteBalanceGain和Toupcam_put_WhiteBalanceGain和Toupcam_AwbInit不能使用，永远返回E_NOTIMPL.<br/>
	b) RGB Gain模式下，必须使用Toupcam_get_WhiteBalanceGain和Toupcam_put_WhiteBalanceGain和Toupcam_AwbInit. 而Toupcam_get_TempTint和Toupcam_put_TempTint和Toupcam_AwbOnePush不能使用，永远返回E_NOTIMPL<br/>
	</blockquote>
<p>Toupcam_Open的id参数之前加'@'字符表示使用RGB Gain模式的白平衡.如果想使用RGB Gain模式白平衡，假设id参数是"abcdef"，则传入参数"@abcdef".</p>
</blockquote>
<p>2. 自动白平衡功能, 业界有两种模式, 一种是连续自动白平衡,一种是触发式自动白平衡(one push). 连续自动白平衡功能会一直进行白平衡参数的计算, 触发模式只是在触发的时候才会计算白平衡参数. Toupcam使用了触发式白平衡计算方法因为这种方法在显微镜等领域更加合适和精确. 连续自动白平衡在某些场景情况下会出现错误.</p>
<p>3. 黑白相机不支持白平衡. 以上提到的函数一直返回E_NOTIMPL.</p>
<h2><font color="#0000FF"><a id="tr">e. 连续(Continuous)模式 vs 触发(Trigger)模式</a></font></h2>
<p>除了连续采集模式以外，一些相机还支持触发采集模式. 在触发模式下，每调用Toupcam_Trigger函数一次采集一帧.</p>
<hr/>
<h1><font color="#0000FF">4. 函数</font></h1>
<hr/>
<ul><li><h2>HRESULT返回值</h2>
	<p>HRESULT在Windows平台上的使用很普遍. OSX和Linux平台上借用之，定义如下:</p>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="20%">名称</td>
        <td width="60%">说明</td>
		<td width="20%">值</td>
      </tr>
	  <tr>
        <td width="20%">S_OK</td>
        <td width="60%">Operation successful (成功)</td>
		<td width="20%">0x00000000</td>
	  </tr>
	  <tr>
        <td width="20%">S_FALSE</td>
        <td width="60%">Operation successful (成功)</td>
		<td width="20%">0x00000001</td>
	  </tr>
	  <tr>
        <td width="20%">E_FAIL</td>
        <td width="60%">Unspecified failure (未指定的错误)</td>
		<td width="20%">0x80004005</td>
	  </tr>
	  <tr>
        <td width="20%">E_INVALIDARG</td>
        <td width="60%">One or more arguments are not valid (参数错误)</td>
		<td width="20%">0x80070057</td>
	  </tr>
	  <tr>
        <td width="20%">E_NOTIMPL</td>
        <td width="60%">Not supported or not implemented (不支持或未实现)</td>
		<td width="20%">0x80004001</td>
	  </tr>
	  <tr>
        <td width="20%">E_POINTER</td>
        <td width="60%">Pointer that is not valid (无效指针)</td>
		<td width="20%">0x80004003</td>
	  </tr>
	  <tr>
        <td width="20%">E_UNEXPECTED</td>
        <td width="60%">Unexpected failure (灾难性故障)</td>
		<td width="20%">0x8000FFFF</td>
	  </tr>
    </table>
  </div><br/>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr><td><pre>#define SUCCEEDED(hr)   (((HRESULT)(hr)) &gt;= 0)
#define FAILED(hr)      (((HRESULT)(hr)) &lt; 0)</pre></td></tr>
</table></div>
</li></ul>
<ul><li><h2>Toupcam_Enum</h2>
  <p><strong>返回值：</strong>非负整数，枚举到的相机数目</p>
  <p><strong>参数：</strong>ToupcamInst缓冲区</p>
  <p><strong>说明：</strong>调用该函数枚举计算机上当前插上的Toupcam相机.函数返回时，ToupcamInst缓冲区包含有枚举到的每个相机实例的信息.<strong>如果不关心多个相机同时联入电脑的情况的话，调用本函数枚举相机实例是可选的.</strong></p>
  <blockquote>
    <p>如下面的代码片段：<br/></p>
<table width="100%" border="0" bgcolor="#B0D0B0">
  <tr><td><pre>
ToupcamInst arr[TOUPCAM_MAX];
unsigned cnt = Toupcam_Enum(arr);
for (unsigned i = 0; i &lt; cnt; ++i)
    ......
</pre></td></tr>
</table><br/>
<table width="100%" border="0" bgcolor="#B0D0B0">
<tr><td><pre>
typedef struct{
#ifdef _WIN32
    const wchar_t*     name;     /* model name */
#else
    const char*        name;
#endif
    unsigned           flag;     /* TOUPCAM_FLAG_xxx */
    unsigned           maxspeed; /* maximum speed level, Toupcam_get_MaxSpeed, the speed range = [0, maxspeed], closed interval */
    unsigned           preview;  /* number of preview resolution, Toupcam_get_ResolutionNumber */
    unsigned           still;    /* number of still resolution, Toupcam_get_StillResolutionNumber */
    ToupcamResolution  res[TOUPCAM_MAX];
}ToupcamModel;
</pre></td></tr>
</table><br/>
<div align="center">
<table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
 <tr>
   <td width="8%" valign="top">name</td>
   <td colspan="2" valign="top">型号名称</td>
   </tr>
 <tr>
   <td width="8%" rowspan="21" valign="top">flag</td>
   <td colspan="2" valign="top">位标记 (Bitwise flag)</td>
   </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CMOS</td>
   <td valign="top">cmos传感器</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CCD_PROGRESSIVE</td>
   <td valign="top">逐行ccd传感器</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CCD_INTERLACED</td>
   <td valign="top">隔行ccd传感器</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_ROI_HARDWARE</td>
   <td valign="top">支持硬件ROI.所谓硬件ROI和软件ROI，前者设置sensor的工作参数，从sensor读取的数据减少（从而提高帧率）;后者不改变sensor的工作参数，从sensor读取的数据量不变，上层软件把原始图像剪切到目标ROI矩形大小.</td> 	
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_MONO</td>
   <td width="63%" valign="top">黑白传感器</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BINSKIP_SUPPORTED</td>
   <td width="63%" valign="top">支持bin/skip模式, 请参考<a href="#binskip">Toupcam_put_Mode和Toupcam_get_Mode</a></td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_USB30</td>
   <td width="63%" valign="top">USB 3.0</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_COOLED</td>
   <td width="63%" valign="top">制冷相机</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_USB30_OVER_USB20</td>
   <td width="63%" valign="top">usb3.0 相机被插入usb2.0端口</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_ST4</td>
   <td width="63%" valign="top">支持ST4端口</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_GETTEMPERATURE</td>
   <td width="63%" valign="top">支持读取温度, Toupcam_get_Temperature</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_PUTTEMPERATURE</td>
   <td width="63%" valign="top">支持设置温度, Toupcam_put_Temperature</td>
 </tr>  
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH10</td>
   <td width="63%" valign="top">最大位深度(Bit Depth) = 10 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH12</td>
   <td width="63%" valign="top">最大位深度(Bit Depth) = 12 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH14</td>
   <td width="63%" valign="top">最大位深度(Bit Depth) = 14 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH16</td>
   <td width="63%" valign="top">最大位深度(Bit Depth) = 16 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_FAN</td>
   <td width="63%" valign="top">支持制冷风扇</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_COOLERONOFF</td>
   <td width="63%" valign="top">制冷装置支持开启/关闭</td>
 </tr>
  <tr>
    <td valign="top">TOUPCAM_FLAG_ISP</td>
    <td valign="top">支持硬件ISP(image signal processing)，降低CPU进行图像处理的CPU利用率</td>
  </tr>
  <tr>
    <td valign="top">TOUPCAM_FLAG_TRIGGER</td>
    <td valign="top">支持触发模式</td>
  </tr>  
 <tr>
   <td width="8%" valign="top">maxspeed</td>
   <td colspan="2" valign="top">最大速度等级，和函数Toupcam_get_MaxSpeed返回值相同. 速度范围是[0, maxspeed]. 可以通过Toupcam_put_Speed设置速度等级, Toupcam_get_Speed获取当前速度等级</td>
   </tr>
 <tr>
   <td width="8%" valign="top">preview</td>
   <td colspan="2" valign="top">预览分辨率的个数. 和函数Toupcam_get_ResolutionNumber返回值相同</td>
   </tr>
 <tr>
   <td width="8%" valign="top">still</td>
   <td colspan="2" valign="top">静态抓拍分辨率个数, 0表示不支持静态抓拍. 和函数Toupcam_get_StillResolutionNumber返回值相同</td>
   </tr>
  <tr>
   <td width="8%" valign="top">res</td>
   <td colspan="2" valign="top">分辨率宽度和高度</td>
   </tr>
</table>
</div>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_HotPlug</h2>
  <p><strong>返回值：</strong>无</p>
  <p><strong>参数：</strong></p>
  <blockquote>
    <p>PTOUPCAM_HOTPLUG pHotPlugCallback: 回调函数</p>
    <blockquote>
    <table width="100%" border="0" bgcolor="#B0D0B0">
      <tr>
        <td><div align="center">typedef void (*PTOUPCAM_HOTPLUG)(void* pCallbackCtx);</div></td>
      </tr>
    </table>
  </blockquote>    
    <p>void* pCallbackCtx: 回调函数上下文</p>
  </blockquote>
  <p><strong>说明：</strong></p><blockquote>
  <p>本函数只存在于OSX和Linux平台，Windows平台不需要.</p>
  <p>在Windows平台处理设备插入/拔出通知，请参阅MSDN(<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363224(v=vs.85).aspx">Device Management</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363215(v=vs.85).aspx">Detecting Media Insertion or Removal</a>).</p>
  <p>在Linux/OSX平台，如果需要处理设备插入/拔出通知，调用本函数注册回调函数. 当设备被插入/拔出时时，程序通过回调函数得到通知，然后调用Toupcam_Enum重新枚举设备即可.</p>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_Open</h2>
    <p> <strong>返回值：</strong>HToupCam句柄.失败时返回NULL（如设备被突然拔出等等）</p>
    <p><strong>参数：</strong>ToupCam相机实例，由Toupcam_Enum枚举得到.<strong>如果</strong><strong>id</strong><strong>是NULL</strong><strong>则自动打开第一个相机，所以，如果不关心多个相机实例同时连入电脑的情况，Toupcam_Enum</strong><strong>不是必须的，直接传入参数NULL</strong><strong>打开唯一的相机实例.</strong></p>
    <p><strong>说明：</strong>打开相机实例.</p>
</li></ul>
<ul><li><h2>Toupcam_Close</h2>
    <p><strong>返回值：</strong>无</p>
    <p><strong>参数：</strong>HToupCam句柄</p>
    <p><strong>说明：</strong>关闭相机实例.句柄关闭之后，请不要再使用之.<strong>不要在</strong><strong>PTOUPCAM_EVENT_CALLBACK和PTOUPCAM_DATA_CALLBACK</strong><strong>回调函数里面调用Toupcam_Close</strong><strong>，否则，会死锁.</strong></p>
</li></ul>
<ul><li><h2>Toupcam_StartPullModeWithWndMsg, Toupcam_StartPullModeWithCallback</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
    <blockquote>
      <p>HToupCam h：由Toupcam_Open打开的实例句柄</p>
      <p>HWND hWnd: 事件发生时，消息将Post到这个窗口</p>
      <p>UINT nMsg: Windows自定义消息类型.消息的WPARAM参数是事件类型TOUPCAM_EVENT_xxxx，LPARAM参数不用（恒等于0）</p>
      <p>PTOUPCAM_EVENT_CALLBACK pEventCallback, void*  pCallbackContext：用户程序指定的回调函数和回调上下文参数. 注意：该回调函数是从toupcam.dll的内部线程上下文中回调出来，所以，非常有必要关注多线程问题. 请尽量保持回调函数代码的简洁，并且快速返回. 不要在回调函数上下文调用Toupcam_Stop或Toupcam_Close函数，否则，会死锁.</p>
      <blockquote>
        <table width="100%" border="0">
          <tr>
            <td bgcolor="#B0D0B0"><div align="center">typedef void (__stdcall* PTOUPCAM_EVENT_CALLBACK)(unsigned nEvent, void* pCallbackCtx);</div></td>
          </tr>
        </table>
      </blockquote>
    </blockquote>
    <p><strong>说明：</strong>很明显，Toupcam_StartPullModeWithWndMsg只支持Windows系统</p>
</li></ul>
<ul><li><h2>Toupcam_PullImage, Toupcam_PullStillImage</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败，不存在图像可供获取时返回E_FAIL</p>
      <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：由Toupcam_Open打开的实例句柄</p>
    <p>void* pImageData：数据缓冲区.用户应用程序必须确保改缓冲区足够大，以容纳图像数据</p>
    <p>int bits：图像颜色位数，支持24, 32, 48和8，分别代表RGB24, RGB32, RGB48, 8位灰度图像. 本参数在RAW模式下没有意义，被忽略</p>
    <p>unsigned* pnWidth, unsigned* pnHeight：图像的宽度高度</p>
  </blockquote>
  <p><strong>说明：</strong>当pImageData为NULL而pnWidth, pnHeight参数不为NULL的时候，可以获取(Peek)是否存在图像以及图像的宽度高度信息</p>
  <blockquote>请保证pImageData缓冲区的大小足够容纳整帧数据，请看下表:
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td colspan="2" valign="top">格式</td>
        <td width="63%" valign="top">缓冲区大小</td>
      </tr>	
      <tr>
        <td width="10%" rowspan="4" valign="top">RGB</td>
        <td width="27%" valign="top">RGB24</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(24 * Width) * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB32</td>
        <td width="63%" valign="top">Width * Height * 4</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB48</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(48 * Width) * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB8灰度图像</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(8 * Width) * Height</td>
      </tr>
      <tr>
        <td width="10%" rowspan="2" valign="top">RAW</td>
        <td width="27%" valign="top">8bits模式</td>
        <td width="63%" valign="top">Width * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">10bits, 12bits, 14bits, 16bits模式</td>
        <td width="63%" valign="top">Width * Height * 2</td>
      </tr>
    </table>
  </div><br/>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr>
   <td>#ifndef DIBWIDTHBYTES<br/>
#define DIBWIDTHBYTES(bits) ((unsigned)(((bits) + 31) &amp; (~31)) / 8)<br/>
#endif<br/></td>
  </tr>
</table></div>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_StartPushMode</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>   </p>
    <blockquote>
      <p>HToupCam h：由Toupcam_Open打开的实例句柄</p>
      <p>PTOUPCAM_DATA_CALLBACK pDataCallback, void* pCallbackCtx：用户程序指定的回调函数和回调上下文参数.toupcam.dll内部从相机得到的图像数据后，会回调该函数.</p>
    </blockquote>
    <blockquote>
        <table width="100%" border="0">
          <tr>
            <td bgcolor="#B0D0B0"><div align="center">typedef void (*PTOUPCAM_DATA_CALLBACK)(const void* pData, const  BITMAPINFOHEADER* pHeader, BOOL bSnap, void* pCallbackCtx);</div></td>
          </tr>
        </table>
    </blockquote>
  	<blockquote>
    <p align="left">如果回调时，pData参数==NULL，表示发生内部错误（如相机被突然拔出等等）. <br/>
      BOOL bSnap参数，TRUE表示是由Toupcam_Snap函数发起的图片抓拍，FALSE表示普通的预览图片（视频）. <br/>
      注意：该回调函数是从toupcam.dll的内部线程上下文中回调出来，所以，非常有必要关注多线程问题. 请尽量保持回调函数代码的简洁，并且快速返回. 不要在回调函数上下文调用Toupcam_Stop或Toupcam_Close函数，否则，会死锁. 正是因为使用Push模式的复杂性，所以，推荐使用Pull模式（特别是使用窗口消息通知事件）.</p>
  </blockquote>
  <p><strong>说明：</strong>开启相机实例.</p>
</li></ul>
<ul><li><h2>Toupcam_Stop</h2>
  <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
  <p><strong>参数：</strong>HToupCam句柄</p>
  <p><strong>说明：</strong>停止相机实例.如果使用推模式（Push Mode），请不要在PTOUPCAM_EVENT_CALLBACK和PTOUPCAM_DATA_CALLBACK回调函数里面调用Toupcam_Stop，否则，会死锁. 停止之后，可以调用Toupcam_StartPushMode重新开启.比如切换视频分辨率：</p>
  <blockquote>
    <p>步骤1：调用Toupcam_Stop停止</p>
    <p>步骤2：调用Toupcam_put_Size或者Toupcam_put_eSize设置新分辨率</p>
    <p>步骤3：调用Toupcam_StartPullModeWithWndMsg或Toupcam_StartPullModeWithCallback或Toupcam_StartPushMode重新开启</p>
  </blockquote>  
</li></ul>
<ul><li><h2>Toupcam_Pause</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>HToupCam句柄</p>
    <p><strong>说明：</strong>暂停或者继续相机实例</p>
</li></ul>
<ul><li><h2>Toupcam_Snap</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
    <blockquote>
      <p>HToupCam h：相机实例句柄</p>
      <p>unsigned nResolutionIndex：想要抓拍的分辨率序号.</p>
    </blockquote>
  <p><strong>说明：</strong>抓拍图片. 抓拍成功之后，如果是Push Mode, 则通过TOUPCAM_EVENT_STILLIMAGE通知. 如果是Push Mode则通过PTOUPCAM_DATA_CALLBACK回调函数返回，其中回调函数的参数BOOL bSnap设为TRUE.</p>
  <blockquote>
    <p align="left">有些相机支持在预览视频的不间断的情况下，抓拍单张的不同于正在视频预览的分辨率的所谓静态图片.例如UCMOS03100KPA，正在预览的分辨率是1024*768，调用Toupcam_Snap(h, 0)抓拍单张第0号分辨率（2048*1536）的图片.预览使用小分辨率（追求更快的帧率），抓拍使用大分辨率（追求更好的图片质量）.这种行为，称之为“静态抓拍”. <br/>
      对于不支持静态抓拍的相机型号，则参数nResolutionIndex的值必须等于当前正在预览的分辨率，否则，函数返回E_UNEXPECTED. <br/>
      某个型号是否支持静态抓拍能力，参见ToupcamModel的still域(大于0).</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_Trigger</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败. 对于不支持触发模式的相机返回E_NOTIMPL</p>
    <p><strong>参数：</strong></p>
    <blockquote>
      <p>HToupCam h：相机实例句柄</p>
    </blockquote>
  <p><strong>说明：</strong>有些相机支持触发模式，参见ToupcamModel的flag之TOUPCAM_FLAG_TRIGGER. 触发模式下，调用本函数执行一次软触发. 触发成功之后，如果是Push Mode, 则通过TOUPCAM_EVENT_IMAGE通知. 如果是Push Mode则通过PTOUPCAM_DATA_CALLBACK回调函数返回，其中回调函数的参数BOOL bSnap设为FALSE.</p>
</li></ul>
<ul><li><h2>Toupcam_put_Size, Toupcam_get_Size, Toupcam_put_eSize, Toupcam_get_eSize</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
      <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned nResolutionIndex：当前分辨率序号</p>
    <p>int nWidth, int nHeight：当前分辨率的宽度高度</p>
  </blockquote>
  <p><strong>说明：</strong>设置或者得到当前分辨率.</p>
  <blockquote>
    <p align="left">设置分辨率应该在Toupcam_StartPullModeWithWndMsg或Toupcam_StartPullModeWithCallback或Toupcam_StartPushMode之前进行. <br/>
      有2种方法设置当前分辨率，一种是通过分辨率的序号，一种是通过宽度/高度.两种方法是等效的.比如UCMOS03100KPA支持以下3种分辨率:<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号0: 2048, 1536<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号1: 1024, 768<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号2: 680, 510<br/>
      所以Toupcam_put_Size(h, 1024, 768) or Toupcam_put_eSize(h, 1)效果一样.</p>
  </blockquote>
</li></ul>  
<ul><li><h2>Toupcam_put_Size, Toupcam_get_Size, Toupcam_put_eSize, Toupcam_get_eSize</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
      <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned nResolutionIndex：当前分辨率序号</p>
    <p>int nWidth, int nHeight：当前分辨率的宽度高度</p>
  </blockquote>
  <p><strong>说明：</strong>设置或者得到当前分辨率.</p>
  <blockquote>
    <p align="left">设置分辨率应该在Toupcam_StartPullModeWithWndMsg或Toupcam_StartPullModeWithCallback或Toupcam_StartPushMode之前进行. <br/>
      有2种方法设置当前分辨率，一种是通过分辨率的序号，一种是通过宽度/高度.两种方法是等效的.比如UCMOS03100KPA支持以下3种分辨率:<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号0: 2048, 1536<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号1: 1024, 768<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;序号2: 680, 510<br/>
      所以Toupcam_put_Size(h, 1024, 768) or Toupcam_put_eSize(h, 1)效果一样.</p>
  </blockquote>
</li></ul>
<ul><li><h2><a id="#roi">Toupcam_put_Roi, Toupcam_get_Roi</a></h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败.</p>
    <p><strong>参数：</strong></p>
    <blockquote>
      <p>HToupCam h: 相机实例句柄</p>
      <p>unsigned xOffset: x偏移，必须是偶数</p>
      <p>unsigned yOffset: y偏移，必须是偶数</p>
      <p>unsigned xWidth: 宽度. 最小值16，必须是偶数</p>
      <p>unsigned yHeight: 高度. 最小值16，必须是偶数</p>
    </blockquote>
  <p>说明: 设置/获取ROI. Toupcam_put_Roi(h, 0, 0, 0, 0)表示清除ROI恢复原始尺寸.</p>
  <blockquote>
  	<p>例外: UHCCD03100KPB, UHCCD05000KPA, UHCCD05100KPA的小分辨率不支持ROI功能, 函数返回值是E_NOTIMPL。</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_get_ResolutionNumber, Toupcam_get_Resolution</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
      <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned nIndex：分辨率序号</p>
    <p>int* pWidth, int* pHeight：宽度、高度</p>
  </blockquote>
  <p><strong>说明：</strong>Toupcam_get_ResolutionNumber得到支持的分辨率个数（如UCMOS03100KPA返回3，表示支持3种分辨率）.Toupcam_get_Resolution得到每种分辨率的高度/宽度.</p>
  <blockquote>
    <p align="left">这些参数在Toupcam_Enum返回相机实例的ToupcamModel都已经包含.</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_get_RawFormat</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败.</p>
      <p><strong>参数：</strong>   </p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned* nFourCC：格式类型，见下表</p>
    <p>unsigned* bitdepth：Bit Depth，如8, 10, 12, 14, 16</p>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr>
   <td>#ifndef MAKEFOURCC<br/>
#define MAKEFOURCC(a, b, c, d) ((uint32_t)(uint8_t)(a) | ((uint32_t)(uint8_t)(b) &lt;&lt; 8) | ((uint32_t)(uint8_t)(c) &lt;&lt; 16) | ((uint32_t)(uint8_t)(d) &lt;&lt; 24))<br/>
#endif<br/></td>
  </tr>
</table></div><br/>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('G', 'B', 'R', 'G')</td>
        <td width="60%" valign="top">GBGBGB...<br/>RGRGRG...<br/>GBGBGB...<br/>RGRGRG...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('R', 'G', 'G', 'B')</td>
        <td width="60%" valign="top">RGRGRG...<br/>GBGBGB...<br/>RGRGRG...<br/>GBGBGB...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('B', 'G', 'G', 'R')</td>
        <td width="60%" valign="top">BGBGBG...<br/>GRGRGR...<br/>BGBGBG...<br/>GRGRGR...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('G', 'R', 'B', 'G')</td>
        <td width="60%" valign="top">GRGRGR...<br/>BGBGBG...<br/>GRGRGR...<br/>BGBGBG...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('Y', 'U', 'Y', 'V')</td>
        <td width="60%" valign="top">YUV4:2:2, 请参阅: <a href="http://www.fourcc.org">http://www.fourcc.org</a></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('Y', 'Y', 'Y', 'Y')</td>
        <td width="60%" valign="top">黑白相机</td>
      </tr>
    </table>
  </div></blockquote>
</li></ul>
<ul><li><h2>Toupcam_put_Option, Toupcam_get_Option</h2>
      <p><strong>返回值：</strong>HRESULT类型表示成功失败.</p>
      <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned iOption：选项，见下表</p>
    <p>unsigned iValue：值，见下表</p>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="21%">选项</td>
        <td width="52%">说明</td>
		<td width="6%">默认值</td>
		<td width="21%">是否可以在调用Toupcam_StartPullModeWithWndMsg或Toupcam_StartPullModeWithCallback或Toupcam_StartPushMode之后设置该值</td>
      </tr>
      <tr>
        <td width="21%">TOUPCAM_OPTION_NOFRAME_TIMEOUT</td>
        <td width="52%">一定时间没有获取到任何一帧完整数据，就报错.<br/>
          1 = 使能本特性;<br/>0 = 禁用</td>
		<td width="6%">1</td>
		<td width="21%">是</td>
      </tr>
      <tr>
        <td width="21%">TOUPCAM_OPTION_THREAD_PRIORITY</td>
        <td width="52%">设置内部线程的优先级.<br/>
          0 = THREAD_PRIORITY_NORMAL;<br/>1 = THREAD_PRIORITY_ABOVE_NORMAL;<br/>2 = THREAD_PRIORITY_HIGHEST;<br/>请参阅: <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686277(v=vs.85).aspx">SetThreadPriority</a><br/>本选项在Linux和OSX平台下被忽略.</td>
		<td width="6%">0</td>
		<td width="21%">是</td>
      </tr>
      <tr>
        <td width="21%">TOUPCAM_OPTION_PROCESSMODE</td>
        <td width="52%">0：full模式，图像质量更好，但是更耗费CPU.<br/>
          1: fast模式，图像质量差些，耗费更少的CPU.<br/>根据具体的使用情况选择FULL模式还是FAST模式.</td>
		<td width="6%">0</td>
		<td width="21%">是</td>
      </tr>
      <tr>
        <td width="21%"><a id="rawo">TOUPCAM_OPTION_RAW</a></td>
        <td width="52%">0表示使用RGB模式.<br/>
          1表示RAW模式，直接获取底层传感器数据.</td>
		<td width="6%">0</td>
		<td width="21%">否<br/>
		  (在相机已经开启的情况下，设置本选项，函数返回E_UNEXPECTED)</td>
      </tr>
	  <tr>
	  	<td width="21%">TOUPCAM_OPTION_BITDEPTH</td>
		<td width="52%">一些型号的相机支持大于8Bits的位深度(Bit Depth)，如10,12,14,16等.<br/>
		  0表示使用8Bits位深度.<br/>1表示使用本相机支持的最高位深度</td>
		<td width="6%">NA</td>
		<td width="21%">是</td>
	  </tr>
      <tr>
      	<td width="21%">TOUPCAM_OPTION_FAN</td>
      	<td width="52%">一些型号的相机支持制冷风扇.<br/>
      	  0 = 关闭风扇<br/>1 = 打开风扇</td>
      	<td width="6%">1</td>
      	<td width="21%">是</td>
      </tr>
      <tr>
      	<td width="21%">TOUPCAM_OPTION_COOLER</td>
      	<td width="52%">一些型号的相机支持开启关闭制冷装置.<br/>
      	  0 = 关闭制冷<br/>1 = 开启制冷</td>
      	<td width="6%">1</td>
      	<td width="21%">是</td>
      </tr>
      <tr>
      	<td width="21%">TOUPCAM_OPTION_LINEAR</td>
      	<td width="52%">0 = 关闭linear tone mapping<br/>
      	  1 = 开启linear tone mapping</td>
      	<td width="6%">1</td>
      	<td width="21%">是</td>
      </tr>
      <tr>
      	<td width="21%">TOUPCAM_OPTION_CURVE</td>
      	<td width="52%">0 = 关闭curve tone mapping<br/>
      	  1 = 开启curve tone mapping</td>
      	<td width="6%">1</td>
      	<td width="21%">是</td>
      </tr>
      <tr>
      	<td width="21%">TOUPCAM_OPTION_TRIGGER</td>
      	<td width="52%">0 = 连续模式<br/>
      	  1 = 触发(Trigger)模式</td>
      	<td width="6%">0</td>
      	<td width="21%">否<br/>
      	  (在相机已经开启的情况下，设置本选项，函数返回E_UNEXPECTED)</td>
      </tr>
      <tr>
      	<td width="21%"><a id="#rgb48">TOUPCAM_OPTION_RGB48</a></td>
      	<td width="52%">在位深度>8时，启用RGB48格式</td>
      	<td width="6%">0</td>
      	<td width="21%">否<br/>
      	  (在相机已经开启的情况下，设置本选项，函数返回E_UNEXPECTED)</td>
      </tr>
    </table>
  </div>
  <p>一般情况下，不需要设置这些选项. 如有必要，请在准确理解这些选项的具体含义时才设置它们.</p>
  <p>UHCCD03100KPB, UHCCD05000KPA, UHCCD05100KPA的小分辨率不支持RAW模式</p>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_put_RealTime, Toupcam_get_RealTime</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>BOOL bEnable：TRUE or FALSE</p>
  </blockquote>
  <p><strong>说明：</strong>如果设置RealTime模式为TRUE，更短的帧延时，但是帧速率降低，流畅性受损.缺省设为FALSE，一般不需要改动.</p>
</li></ul>
<ul><li><h2>Toupcam_get_AutoExpoEnable, Toupcam_put_AutoExpoEnable, Toupcam_get_AutoExpoTarget, Toupcam_put_AutoExpoTarget, Toupcam_put_MaxAutoExpoTimeAGain</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>   </p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>BOOL bAutoExposure：TRUE or FALSE</p>
    <p>unsigned short Target：自动曝光目标</p>
    <p>unsigned maxTime, unsigned short maxAGain：自动曝光的最大曝光时间和最大模拟增益</p>
  </blockquote>
  <p><strong>说明：</strong>如果启用自动曝光，软件将自动设置曝光时间和模拟增益使得目标矩形的平均亮度尽量接近曝光目标(见Toupcam_put_AEAuxRect, Toupcam_get_AEAuxRect).</p>
</li></ul>
<ul><li><h2>Toupcam_get_ExpoTime, Toupcam_put_ExpoTime, Toupcam_get_ExpTimeRange</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned Time：曝光时间，单位微秒</p>
    <p>unsigned* nMin, unsigned* nMax, unsigned* nDef：曝光时间的最小值，最大值，默认值</p>
  </blockquote>
  <p><strong>说明：</strong>曝光时间相关.</p>
</li></ul>
<ul><li><h2>Toupcam_get_ExpoAGain, Toupcam_put_ExpoAGain, Toupcam_get_ExpoAGainRange</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>   </p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned short AGain：模拟增益，百分比，如200表示增益200%</p>
    <p>unsigned short* nMin, unsigned short* nMax, unsigned short* nDef：模拟增益的最小值，最大值，默认值</p>
  </blockquote>
  <p><strong>说明：</strong>模拟增益相关.</p>
</li></ul>
<ul><li><h2>Toupcam_put_Hue, Toupcam_get_Hue, Toupcam_put_Saturation, Toupcam_get_Saturation,  Toupcam_put_Brightness, Toupcam_get_Brightness, Toupcam_get_Contrast, Toupcam_put_Contrast,  Toupcam_get_Gamma, Toupcam_put_Gamma</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>设置或者得到：色度，饱和度，亮度，对比度，Gamma</p>
</li></ul>
<ul><li><h2>Toupcam_get_Chrome, Toupcam_put_Chrome</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>BOOL bChrome：TRUE or FALSE</p>
  </blockquote>
  <p><strong>说明：</strong>多色模式或者单色模式.</p>
</li></ul>
<ul><li><h2>Toupcam_get_VFlip, Toupcam_put_VFlip, Toupcam_get_HFlip, Toupcam_put_HFlip</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong> HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>垂直或者水平翻转</p>
</li></ul>
<ul><li><h2>Toupcam_put_Speed, Toupcam_get_Speed, Toupcam_get_MaxSpeed</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned short nSpeed：帧速率级别</p>
  </blockquote>
  <p><strong>说明：</strong>最小帧速率等级是0.最大帧速率级别可以通过Toupcam_get_MaxSpeed函数得到，和ToupcamModel的maxspeed是一个意思.</p>
</li></ul>
<ul><li><h2>Toupcam_put_HZ, Toupcam_get_HZ</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>int nHZ：0表示60Hz交流，1表示50Hz交流，2表示直流</p>
  </blockquote>
  <p><strong>说明：</strong>设置光源的电力供应频率</p>
</li></ul>
<ul><li><h2>Toupcam_get_Temperature, Toupcam_put_Temperature</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败, E_NOTIMPL表示不支持读取/设置温度</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>short nTemperature：以0.1摄氏度为单位，如32表示3.2摄氏度.</p>
  </blockquote>
  <p><strong>说明：</strong>读取传感器温度(TOUPCAM_FLAG_GETTEMPERATURE表示支持读取温度).</p>
  <blockquote><p>设置传感器目标温度(制冷目标温度, TOUPCAM_FLAG_PUTTEMPERATURE表示支持设置温度.</p></blockquote>
</li></ul>
<ul><li><h2><a id="#binskip">Toupcam_put_Mode, Toupcam_get_Mode</a></h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>BOOL bSkip：Bin模式或者Skip模式</p>
  </blockquote>
  <p><strong>说明：</strong>设置Bin模式或者Skip模式.较高分辨率的相机支持2种采样模式，一种是Bin模式（邻域平均），一种是Skip模式（抽样提取）.相比较而言，前者图像效果较好，但是帧速率降低；后者帧速率较高，但是图像效果较差.</p>
</li></ul>
<ul><li><h2>Toupcam_put_TempTint, Toupcam_get_TempTint</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败. Temp/Tint模式下起作用，RGB Gain模式下不起作用直接返回E_NOTIMPL.</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>int nTemp, int nTint：色温和Tint</p>
  </blockquote>
  <p><strong>说明：</strong>Temp/Tint模式下设置/获取白平衡的色温和Tint参数.请参阅<a href="#wb">这里</a>.</p>
</li></ul>
<ul><li><h2>Toupcam_AwbOnePush</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败. Temp/Tint模式下起作用，RGB Gain模式下不起作用直接返回E_NOTIMPL.</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>PITOUPCAM_TEMPTINT_CALLBACK fnTTProc, void* pTTCtx：自动白平衡过程完成时的回调函数以及回调上下文.</p>
  </blockquote>
  <p>说明: Temp/Tint白平衡模式下调用本函数来触发单次自动白平衡功能. 当白平衡参数计算完成的时候, TOUPCAM_EVENT_TEMPTINT事件会通知应用程序(Pull Mode)和调用回调函数. Pull mode中, 如果不使用回调函数, 请把函数指针设为NULL.</p>
</li></ul>
<ul><li><h2>Toupcam_put_WhiteBalanceGain, Toupcam_get_WhiteBalanceGain</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败. RGB Gain模式下起作用，Temp/Tint模式下不起作用直接返回E_NOTIMPL.</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>int aGain[3]：RGB增益值</p>
  </blockquote>
  <p><strong>说明：</strong>RGB Gain模式下设置/获取白平衡的RGB增益值.请参阅<a href="#wb">这里</a>.</p>
</li></ul>
<ul><li><h2>Toupcam_AwbInit</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败. RGB Gain模式下起作用，Temp/Tint模式下不起作用直接返回E_NOTIMPL.</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>PITOUPCAM_WHITEBALANCE_CALLBACK fnWBProc, void* pWBCtx：自动白平衡过程完成时的回调函数以及回调上下文.</p>
  </blockquote>
  <p>说明: RGB Gain白平衡模式下调用本函数来触发单次自动白平衡功能. 当白平衡参数计算完成的时候, TOUPCAM_EVENT_WBGAIN事件会通知应用程序(Pull Mode)和调用回调函数. Pull mode中, 如果不使用回调函数, 请把函数指针设为NULL.</p>
</li></ul>
<ul><li><h2>Toupcam_put_AWBAuxRect, Toupcam_get_AWBAuxRect, Toupcam_put_AEAuxRect, Toupcam_get_AEAuxRect</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>设置/获取自动白平衡和自动曝光的参考矩形.默认矩形位于图像正中央,宽度等于20%图像宽度,高度等于20%图像高度.</p>
</li></ul>
<ul><li><h2>Toupcam_get_MonoMode</h2>
    <p><strong>返回值：</strong>S_OK表示单色模式，S_FALSE表示彩色模式</p>
    <p><strong>参数：</strong>HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>是否单色相机，对应ToupCamModel的flag: TOUPCAM_FLAG_MONO</p>
</li></ul>
<ul><li><h2>Toupcam_get_MaxBitDepth</h2>
    <p><strong>返回值：</strong>相机支持的最大位深度(Bit Depth)</p>
    <p><strong>参数：</strong>HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>有些型号的相机支持比8bits更大的位深度，如10, 12, 14, 16等.</p>
</li></ul>
<ul><li><h2>Toupcam_get_StillResolutionNumber, Toupcam_get_StillResolution</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned nIndex：分辨率序号</p>
    <p>int* pWidth, int* pHeight：宽度、高度</p>
  </blockquote>
  <p><strong>说明：</strong>Toupcam_get_StillResolutionNumber得到支持的静态抓拍分辨率个数（如UCMOS03100KPA返回3，表示支持3种分辨率），如果不支持静态抓拍能力，返回0.Toupcam_get_StillResolution得到每种分辨率的高度/宽度.</p>
</li></ul>
<ul><li><h2>Toupcam_get_SerialNumber, Toupcam_get_FwVersion, Toupcam_get_HwVersion, Toupcam_get_ProductionDate</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>char sn[32]：存放序列号的缓冲区. 如：TP110826145730ABCD1234FEDC56787</p>
    <p>char fwver[16]: 存放固件版本号的缓冲区. 如: 3.2.1.20140922</p>
    <p>char hwver[16]: 存放硬件版本好的缓冲区. 如: 3.2.1.20140922</p>
    <p>char pdate[10]: 存放生产日期的缓冲区. 如: 20150327</p>
  </blockquote>
  <p><strong>说明：</strong>每个相机都有一个唯一的31位的序列号.如：“TP110826145730ABCD1234FEDC56787”</p>
</li></ul>
<ul><li><h2>Toupcam_put_LEDState</h2>
  <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
  <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned short iLed：LED灯的序号</p>
    <p>unsigned short iState：LED状态，1代表常亮，2代表闪烁，其它代表熄灭</p>
    <p>unsigned short iPeriod：闪烁周期，毫秒数. 至少需要500ms.</p>
  </blockquote>
  <p><strong>说明：</strong>有些相机上安装有1到n个LED灯，本函数控制这些灯的状态.</p>
</li></ul>
<ul><li><h2>Toupcam_read_EEPROM, Toupcam_read_EEPROM</h2>
  <p><strong>返回值：</strong>HRESULT类型表示失败或读写的字节数</p>
  <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned addr: EEPROM读写地址</p>
    <p>const unsigned char* pData: 需要写入EEPROM的数据</p>
    <p>unsigned char* pBuffer: 读取EEPROM的缓冲区</p>
    <p>unsigned nDataLen: 需要写入EEPROM的数据长度</p>
    <p>unsigned nBufferLen: 读取缓冲区长度</p>
  </blockquote>
  <p><strong>说明：</strong>有些相机上安装有EEPROM可供读写.读写失败时返回HRESULT错误码（负数），成功时返回读取或者写入的字节数.</p>
</li></ul>
<ul><li><h2>Toupcam_put_ExpoCallback</h2>
  <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
  <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>PITOUPCAM_EXPOSURE_CALLBACK fnExpoProc, void* pExpoCtx：曝光回调函数以及回调上下文.设置fnExpoProc为NULL，表示停止回调.</p>
  </blockquote>
  <p><strong>说明：</strong>一旦设置了非NULL的回调函数，每当曝光时间变化时，回调发生.设置fnExpoProc为NULL，表示不再回调.</p>
</li></ul>
<ul><li><h2>Toupcam_put_ChromeCallback</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>PITOUPCAM_CHROME_CALLBACK fnChromeProc, void* pChromeCtx：多色/单色切换回调函数以及回调上下文.设置fnChromeProc为NULL，表示不再回调.</p>
  </blockquote>
  <p><strong>说明：</strong>一旦设置了非NULL的回调函数，每当单色/多色切换时（如调用Toupcam_put_Chrome），回调发生.</p>
</li></ul>
<ul><li><h2>Toupcam_LevelRangeAuto</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong>HToupCam h：相机实例句柄</p>
    <p><strong>说明：</strong>自动LevelRange</p>
</li></ul>
<ul><li><h2>Toupcam_put_LevelRange, Toupcam_get_LevelRange</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>unsigned short aLow[4], unsigned short aHigh[4]: R, G, B和灰度的Level Range. RGB只对彩色图像有效, 灰度只对灰度图像有效.</p>
  </blockquote>
  <p><strong>说明：</strong>LevelRange相关.</p>
</li></ul>
<ul><li><h2>Toupcam_GetHistogram</h2>
    <p><strong>返回值：</strong>HRESULT类型表示成功失败</p>
    <p><strong>参数：</strong></p>
  <blockquote>
    <p>HToupCam h：相机实例句柄</p>
    <p>PITOUPCAM_HISTOGRAM_CALLBACK fnHistogramProc, void* pHistogramCtx：直方图数据的回调函数以及回调上下文</p>
  </blockquote>
  <p><strong>说明：</strong>获取直方图数据</p>
</li></ul>
<hr/>
<h1><font color="#0000FF">5. .NET, C#和VB.NET</font></h1>
<hr/>
<p>Toupcam支持.NET开发环境(C#和VB.NET).</p>
<p>inc目录下toupcam.cs使用P/Invoke调用至toupcam.dll.  把toupcam.cs 拷贝到你的C#工程中使用，请参考例子代码samples\toupcamdemowinformcs1和toupcamdemowinformcs2.</p>
<p>ToupTek.ToupCam C#包装类的属性和方法等等，直接调用toupcam.dll中对应的原生C/C++ Toupcam_xxx函数. 所以，关于Toupcam_xxx的文档说明都适用于C#中对应的属性或方法，比如，C#中的Snap方法调用Toupcam_Snap函数，关于Toupcam_Snap函数的说明同样适用于C# ToupCam类的Snap方法：</p>
<table width="100%" border="0" bgcolor="#B0D0B0">
<tr><td><pre>[DllImport(&quot;toupcam.dll&quot;, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
private static extern int Toupcam_Snap(SafeHToupCamHandle h, uint nResolutionIndex);

public bool Snap(uint nResolutionIndex)
{
    if (_handle == null || _handle.IsInvalid || _handle.IsClosed)
        return false;
    return (Toupcam_Snap(_handle, nResolutionIndex) &gt;= 0);
}</pre></td></tr></table>
<p>VB.NET和C#是类似的，不另说明.</p>
<hr/>
<h1><font color="#0000FF">6. 其他</font></h1>
<hr/>
<ul><li>字节序(BGR vs RGB)
    <blockquote>
      <p>Windows: BGR</p>
      <p>OSX, Linux: RGB</p>
    </blockquote>
</li></ul>
<ul>
  <li>一些参数的范围以及默认值</li>
</ul>
<blockquote>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td colspan="3">参数</td>
        <td width="9%">范围</td>
        <td width="9%">默认值</td>
        <td width="19%">获取</td>
        <td width="17%">设置</td>
        <td width="15%">自动</td>
      </tr>
      <tr>
        <td colspan="3">AutoExpoTarget<br/>(自动曝光目标亮度)</td>
        <td width="9%">16~235</td>
        <td width="9%">120</td>
        <td width="19%">Toupcam_get_AutoExpoTarget</td>
        <td width="17%">Toupcam_put_AutoExpoTarget</td>
        <td width="15%">&nbsp;</td>
      </tr>
      <tr>
        <td width="13%" rowspan="5">白平衡</td>
        <td width="10%" rowspan="2">Temp/Tint模式</td>
        <td width="8%">Temp(色温)</td>
        <td width="9%">2000~15000</td>
        <td width="9%">6503</td>
        <td width="19%" rowspan="2">Toupcam_get_TempTint</td>
        <td width="17%" rowspan="2">Toupcam_put_TempTint</td>
        <td width="15%" rowspan="2">Toupcam_AwbOnePush</td>
      </tr>
      <tr>
        <td width="8%">Tint</td>
        <td width="9%">200~2500</td>
        <td width="9%">1000</td>
      </tr>
      <tr>
        <td rowspan="3">RGB Gain模式 </td>
        <td height="21">Red Gain</td>
        <td rowspan="3">-128~128</td>
        <td rowspan="3">0</td>
        <td rowspan="3">Toupcam_get_WhiteBalanceGain</td>
        <td rowspan="3">Toupcam_put_WhiteBalanceGain</td>
        <td rowspan="3">Toupcam_AwbInit</td>
      </tr>
      <tr>
        <td>Green Gain</td>
      </tr>
      <tr>
        <td>Blue  Gain</td>
      </tr>
      <tr>
        <td colspan="3">LevelRange</td>
        <td width="9%">0~255</td>
        <td width="9%">Low = 0<br/>
        High = 255</td>
        <td width="19%">Toupcam_get_LevelRange</td>
        <td width="17%">Toupcam_put_LevelRange</td>
        <td width="15%">Toupcam_LevelRangeAuto</td>
      </tr>
      <tr>
        <td colspan="3">Contrast(对比度)</td>
        <td width="9%">-100~100</td>
        <td width="9%">0</td>
        <td width="19%">Toupcam_get_Contrast</td>
        <td width="17%">Toupcam_put_Contrast</td>
        <td width="15%">&nbsp;</td>
      </tr>
      <tr>
        <td colspan="3">Hue(色度)</td>
        <td width="9%">-180~180</td>
        <td width="9%">0</td>
        <td width="19%">Toupcam_get_Hue</td>
        <td width="17%">Toupcam_put_Hue</td>
        <td width="15%">&nbsp;</td>
      </tr>
      <tr>
        <td colspan="3">Saturation(饱和度)</td>
        <td width="9%">0~255</td>
        <td width="9%">128</td>
        <td width="19%">Toupcam_get_Saturation;</td>
        <td width="17%">Toupcam_put_Saturation</td>
        <td width="15%">&nbsp;</td>
      </tr>
      <tr>
        <td colspan="3">Brightness(亮度)</td>
        <td width="9%">-64~64</td>
        <td width="9%">0</td>
        <td width="19%">Toupcam_get_Brightness</td>
        <td width="17%">Toupcam_put_Brightness</td>
        <td width="15%">&nbsp;</td>
      </tr>
      <tr>
        <td colspan="3">Gamma</td>
        <td width="9%">20~180</td>
        <td width="9%">100</td>
        <td width="19%">Toupcam_get_Gamma</td>
        <td width="17%">Toupcam_put_Gamma</td>
        <td width="15%">&nbsp;</td>
      </tr>
    </table>
  </div>
</blockquote>
<ul>
  <li>平台
    <ul>
      <li>Windows: CPU至少需要支持SSE2指令集
        <ul>
          <li>x86: XP SP3及以上版本</li>
          <li>x64: Win7以以上版本</li>
        </ul>
      </li>
      <li>OSX: x64；10.7或以上版本</li>
      <li>Linux: CPU至少需要支持SSE3指令集；内核2.6.27及以上. (内核2.6.27发布于2008年10月)
        <ul>
          <li>x86: GLIBC 2.8及以上. (GLIBC 2.8发布于2008年11月)</li>
          <li>x64: GLIBC 2.14及以上. (GLIBC 2.14发布于2011年6月)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<hr/>
<h1><font color="#0000ff">7. 更新历史</font></h1>
<hr/>
<p>v1.6: 位深度>8时支持RGB48格式输出, 请参阅<a href="#rgb48">这里</a></p>
<p>v1.5: 支持触发(Trigger)模式</p>
<p>v1.4: 白平衡的两种模式: Temp/Tint模式 vs RGB Gain模式, 请参阅<a href="#wb">这里</a></p>
<p>v1.3: 支持ROI (Region Of Interest), 请参阅<a href="#roi">这里</a></p>
<p>v1.2: 支持更多的位深度(bit depth): 10bits, 12bits, 14bits, 16bits</p>
<p>v1.1: 支持RAW模式，请参阅<a href="#raw">这里</a>和请参阅<a href="#rawo">这里</a>；增加对Linux和OSX的支持</p>
<p>v1.0: 初始发布</p>
<hr/>
<h1><font color="#0000FF">8. 联系信息</font></h1>
<hr/>
<p>如果在使用ToupCam SDK的过程中，碰到任何问题，请与我们联系<br/>
  网站：<a href="http://www.touptek.com">www.touptek.com</a> <a href="http://www.toupcam.com">www.toupcam.com</a><br/>
  QQ:862347751<br/>
  EMAIL：support@touptek.com</p>
</body>
</html>
