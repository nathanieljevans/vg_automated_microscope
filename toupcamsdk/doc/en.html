<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
<title>ToupCam API Manual</title>
</head>
<body>
<h1 align="center">ToupCam API Manual</h1>
<hr/>
<h1><font color="#0000FF">1. Version</font></h1>
<hr/>
<blockquote>
  <p>1.6.5660.20150520</p>
</blockquote>
<hr/>
<h1><font color="#0000FF">2. Introduction</font></h1>
<hr/>
<p>ToupCam cameras (model series: UCMOS, WCMOS, LCMOS, U3CMOS, L3CMOS, E3CMOS, ICMOS, GCMOS, UHCCD, EXCCD, SCCCD) support various kinds of APIs (Application Program Interface), namely
 Native C/C++, .NET/C#/VB.NET, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd375454(v=vs.85).aspx">DirectShow</a>, <a href="http://twain.org/">Twain</a>, LabView and so on. Compared with other APIs, Native C/C++ API, as a low level API, don't depend any other runtime libraries. Besides, this interface is simple, flexible and easy to be integrated into the customized applications. 
The SDK zip file contains all of the necessary resources and information:</p>
<ul><li>inc</li></ul>
<blockquote>
 <p align="left">toupcam.h, C/C++ head file<br/></p>
</blockquote>
<ul>
 <li>win: For Microsoft Windows
   <ul>
     <li>inc
     <blockquote>
       <p align="left">toupcam.cs, for C#. The toupcam.cs use P/Invoke to call into toupcam.dll. Please copy toupcam.cs to your C# project to use it.<br/>
         toupcam.vb, for VB.NET. The toupcam.vb use P/Invoke to call into toupcam.dll. Please copy toupcam.vb to your VB.NET project to use it.<br/>
      </p>
     </blockquote></li>
     <li>x86
     <blockquote>
       <p align="left">toupcam.lib, lib file for x86.<br/>
         toupcam.dll, dll file for x86.<br/>
         toupcamdemocpp.exe, x86 C++ demo exe file.</p>
     </blockquote></li>
     <li>x64
      <blockquote>
        <p align="left">toupcam.lib, lib file for x64.<br/>
          toupcam.dll, dll file for x64.<br/>
         toupcamdemocpp.exe, x64 C++ demo exe file.</p>
      </blockquote></li>
     <li>drivers
       <blockquote>
         <p align="left">x86 folder contains the kernel mode drivers for x86, including toupcam.cat, toupcam.inf and toupcam.sys.<br/>
           x64 folder contains the kennel mode driver for x64, including toupcam.cat, toupcam.inf and toupcam.sys.</p>
       </blockquote>
     </li>
     <li>samples
       <blockquote>
         <p>a). toupcamdemocpp, C++ sample. It demonstrates to enumerate device, open device, video preview, image capture, set the preview resolution, multi-format image saving (.bmp, .jpg, .png, etc), wmv format video recording and so on. This sample use Pull Mode. To keep the code clean, this sample uses the WTL library which can be downloaded from <a href="http://sourceforge.net/projects/wtl/">http://sourceforge.net/projects/wtl</a></p>
         <p>b). toupcamdemomfc, a simple C++ sample. It use MFC as the GUI library. It demonstrates to open device, video preview, image capture, set the preview resolution, multi-format image saving (.bmp, .jpg, .png, etc). This sample use Pull Mode.</p>
         <p>c). toupcamdemowinformcs1, C# winform sample. This sample use Pull Mode, StartPullModeWithWndMsg.</p>
         <p>d). toupcamdemowinformcs2, C# winform sample. This sample use Pull Mode, StartPullModeWithCallback.</p>
         <p>e). toupcamdemowinformvb, VB.NET winform sample. This sample use Pull Mode.</p>
       </blockquote>
      </li>
     <li>extras
       <blockquote>
         <p align="left">a). directshow: DirectShow SDK and demo.<br/>
           b). twain: TWAIN SDK and demo.<br/>
           c). labview: Labview SDK and demo.</p>
       </blockquote>
     </li>
   </ul>
</li>
</ul>
 <ul><li>linux: For Linux
 	<ul>
 	<li>udev: 99-toupcam.rules, udev rule file. Please see: <a href="http://reactivated.net/writing_udev_rules.html">http://reactivated.net/writing_udev_rules.html</a></li>
     <li>inc: toupcam.cs, for Mono C#. The toupcam.cs use P/Invoke to call into libtoupcam.so. Please copy toupcam.cs to your C# project to use it.</li>
     <li>x86: libtoupcam.so, so file for x86.</li>
     <li>x64: libtoupcam.so, so file for x64.</li>
	</ul>
 	</li></ul>
 <ul><li>osx: For MAC OSX.</li></ul>
 <ul><li>doc: User manuals in English and Chinese.</li></ul>
 <hr/>
<h1><font color="#0000FF">3. Concepts and terminology</font></h1>
<hr/>
<h2><font color="#0000FF">a. Modes for accessing image data: "Pull Mode" vs "Push Mode"</font></h2>
<p>Toupcam offers two modes to obtain image data: Pull Mode and Push Mode. The former is recommended since it's simpler and the application seldom gets stuck in multithreading conditions, especially when using windows message to notify the events.</p>
<ul>
  <li>In Pull Mode, toupcam plays a passive role and the application 'PULL' image data from toupcam. The internal thread of toupcam obtains image data from the camera hardware and saves them to the internal buffers, then notify the application (see below). The application then call functions Toupcam_PullImage and Toupcam_PullStillImage to access image data.</li>
</ul>
<blockquote>
 <p>There are to ways to notify applications:</p>
<blockquote>
 <p>a) Use Windows message: Start pull mode by using the function Toupcam_StartPullModeWithWndMsg. When event occurs, toupcam will post message (PostMessage) to the specified window. Parameter WPARAM is the event type, refer to the definition of TOUPCAM_EVENT_xxxx. This model avoids the multithreading issues, so it's the most simple way. (Obviously, this is only supported in Windows systems, and not supported in Linux and MacOSX.)</p>
 <p>b) Use Callback function: Start pull mode by using the function Toupcam_StartPullModeWithCallback. When event occurs, toupcam will callback the function PTOUPCAM_EVENT_CALLBACK.</p>
</blockquote>
</blockquote>
<blockquote>
 <p>In Pull Mode, the SDK could not only notify the application that the image data or still image are available for 'PULL', but also inform you of the other events, such as:</p>
<div align="center">
<table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
 <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_EXPOSURE</td>
   <td width="73%" valign="top">exposure time changes</td>
 </tr>
 <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_TEMPTINT</td>
   <td width="73%" valign="top">white balance parameters changes. Temp/Tint Mode, please see <a href="#wb">here</a>.</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_EVENT_TEMPTINT</td>
   <td valign="top">white balance parameters changes. RGB Gain Mode, please see <a href="#wb">here</a>.</td>
 </tr>
 <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_IMAGE</td>
   <td width="73%" valign="top">Video image data arrives. Use Toupcam_PullImage to 'pull' the image data</td>
 </tr>
 <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_STILLIMAGE</td>
   <td width="73%" valign="top">Still image which is triggered by function Toupcam_Snap arrives. Use Toupcam_PullStillImage to 'pull' the image data</td>
 </tr>
 <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_ERROR</td>
   <td width="73%" valign="top">Error occurs, data acquisition cannot continue</td>
 </tr>
  <tr>
   <td width="27%" valign="top">TOUPCAM_EVENT_DISCONNECTED</td>
   <td width="73%" valign="top">Camera disconnected, maybe has been pulled out</td>
 </tr>
</table>
</div>
</blockquote>
<ul>
  <li>In Push Mode, toupcam plays an active role. Once the video data is obtained from camera by internal thread, toupcam will 'PUSH' the image data to the application through PTOUPCAM_DATA_CALLBACK. Call the function Toupcam_StartPushMode to start push mode. Push mode is more complex. There are some special precautions, such as multithread issues, being impossible to call Toupcam_Close and Toupcam_Stop in callback function PTOUPCAM_DATA_CALLBACK, etc.</li>
</ul>
<h2><font color="#0000FF">b. Still Capture (Still Image)</font></h2>
<p>Most cameras support the so-called still capture capability. This function switches the camera to another resolution temporarily when the camera is in preview mode, after a "still" image in the new resolution is captured and then switch back to the original resolution and resume preview mode.</p>
<p>For example, UCMOS05100KPA support 3 resolutions and the current one in preview mode is 1280 * 960. Call Toupcam_Snap(h, 0) to "still capture" an image in 2592 * 1944 resolution. To realize this function, the camera will temporarily switch to 2592 * 1944 firstly, get an image in 2592 * 1944 resolution and then switch back to 1280 * 960 and resume preview.</p>
<blockquote>a) In pull mode operation, after the still capture, TOUPCAM_EVENT_STILLIMAGE will be sent out for external acknowledgement. The external application should call Toupcam_PullStillImage to get the still captured image.</blockquote>
<blockquote>b) In push mode operation, after the still capture, the callback function PTOUPCAM_DATA_CALLBACK will be called with bSnap parameter setting TRUE. The image information including the resolution information will be obtained via the parameter pHeader.</blockquote>
<p>To check whether the camera have the still capture capability, call Toupcam_get_StillResolutionNumber function or check the still field of the struct ToupcamModel.</p>
<h2><font color="#0000FF"><a id="raw">c. Data format: RGB vs RAW</a></font></h2>
<p>Toupcam supports two data formats: RGB format (default) and RAW format. RAW format could be enabled by assigning TOUPCAM_OPTION_RAW parameter to 1 when calling Toupcam_put_Option function.</p>
<ul><li>RGB format: The output of every pixel contains 3 BYTEs (8bits every color) which stand for R/G/B value respectively. This output is a processed output from the internal color processing engine.</li></ul>
<ul><li>RAW format: In this format, the output is the raw data directly output from the sensor. The RAW format is for the users that want to skip the internal color processing and obtain the raw data for user-specific purpose. With the raw format output enabled, the functions that are related to the internal color processing will not work, such as Toupcam_put_Hue or Toupcam_AwbOnePush function and so on.</li></ul>
<p>Users could switch these two format by calling Toupcam_put_Option function with different value setting to TOUPCAM_OPTION_RAW. You must call this function BEFORE the camera start function (Toupcam_StartPullModeWithWndMsg or Toupcam_StartPullModeWithCallback or Toupcam_StartPushMode).</p>
<h2><font color="#0000FF"><a id="wb">d. White Balance and Auto White Balance: Temp/Tint mode vs RGB Gain mode</a></font></h2>
<p>1. Toupcam sdk supports two independent modes for white balance: a) Temp/Tint Mode; b) RGB Gain Mode</p>
<blockquote>
<p>a) Temp/Tint mode is the default white balance mode. In this mode, temp and tint are the parameters that could be used to control the white balance. Toupcam_get_TempTint function is used to acquire the temp and tint values and Toupcam_put_TempTint is used to set the temp and tint values. Function Toupcam_AwbOnePush is used to execute the auto white balance. When the white balance parameters change, TOUPCAM_EVENT_TEMPTINT event will be notified for external use.</p>
<p>b) In RGB Gain mode, the while balace is controled by the gain values of the R,G,B channels. Toupcam_get_WhiteBalanceGain is used to acquire the parameters and Toupcam_put_WhiteBalanceGain is used to set the white balance parameters. Toupcam_AwbInit is used to execute the execute the auto white balance. When the white balance parameters change, TOUPCAM_EVENT_WBGAIN event will be notified for external use.</p>
<p>The functions for these two modes cannot be misused:</p>
	<blockquote>
	a) In Temp/Tint mode, please use Toupcam_get_TempTint and Toupcam_put_TempTint and Toupcam_AwbOnePush. Toupcam_get_WhiteBalanceGain and Toupcam_put_WhiteBalanceGain and Toupcam_AwbInit cannot be used, they always return E_NOTIMPL.<br/>
	b) In RGB Gain mode, please use Toupcam_get_WhiteBalanceGain and Toupcam_put_WhiteBalanceGain and Toupcam_AwbInit. Toupcam_get_TempTint and Toupcam_put_TempTint and Toupcam_AwbOnePush cannot be used, they always return E_NOTIMPL<br/>
	</blockquote>
<p>When calling Toupcam_Open function, whether to add a '@' character at the beginning of the id parameter will determine the white balance mode. Add a '@' character at the beginning of the id parameter means the RGB gain mode. If you want to use the RGB Gain mode, for example, if the id parameter is "abcdef", please call the Toupcam_Open function with the id parameter "@abcdef".</p>
</blockquote>
<p>2. There are two auto white balance mechanisms available in this field: one is continuous auto white balance and the other is a "one push" auto white balance. The white balance parameters will be always calculated and updated for the continuous auto white balance mechanism. For "one push" auto white balance mechanism, the white balance parameters will be calculated and updated only when triggered. Toupcam cameras support "one push" auto white balance mechanism since it is more accurate and propriate for the microscope application, especially when the background is in pure color. Continuous white balance mechanism will encounter some problem in some cases.</p>
<p>3. Monochromatic camera does not support white balance. The functions metioned above always return E_NOTIMPL.</p>
<hr/>
<h1><font color="#0000FF">4. Functions</font></h1>
<hr/>
<ul><li><h2>HRESULT return value</h2>
	<p>HRESULT is not uncommon on the Windows platform. It's borrowed to OSX and Linux, see the table:</p>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="20%">Name</td>
        <td width="60%">Description</td>
		<td width="20%">Value</td>
      </tr>
	  <tr>
        <td width="20%">S_OK</td>
        <td width="60%">Operation successful</td>
		<td width="20%">0x00000000</td>
	  </tr>
	  <tr>
        <td width="20%">S_FALSE</td>
        <td width="60%">Operation successful</td>
		<td width="20%">0x00000001</td>
	  </tr>
	  <tr>
        <td width="20%">E_FAIL</td>
        <td width="60%">Unspecified failure</td>
		<td width="20%">0x80004005</td>
	  </tr>
	  <tr>
        <td width="20%">E_INVALIDARG</td>
        <td width="60%">One or more arguments are not valid</td>
		<td width="20%">0x80070057</td>
	  </tr>
	  <tr>
        <td width="20%">E_NOTIMPL</td>
        <td width="60%">Not supported or not implemented</td>
		<td width="20%">0x80004001</td>
	  </tr>
	  <tr>
        <td width="20%">E_POINTER</td>
        <td width="60%">Pointer that is not valid</td>
		<td width="20%">0x80004003</td>
	  </tr>
	  <tr>
        <td width="20%">E_UNEXPECTED</td>
        <td width="60%">Unexpected failure</td>
		<td width="20%">0x8000FFFF</td>
	  </tr>
    </table>
  </div><br/>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr><td><pre>#define SUCCEEDED(hr)   (((HRESULT)(hr)) &gt;= 0)
#define FAILED(hr)      (((HRESULT)(hr)) &lt; 0)</pre></td></tr>
</table></div>
</li></ul>
<ul><li><h2>Toupcam_Enum</h2>
    <p><strong>Return value:</strong> non-negative integer, enumerated camera number</p>
    <p><strong>Parameters:</strong></p>
    	<blockquote>
    		<p>ToupcamInst pti[TOUPCAM_MAX]: ToupcamInst buffer</p>
    	</blockquote>
    <p><strong>Remarks:</strong> call this function to enumerate ToupCam cameras that are currently connected to computer and when it is returned, ToupcamInst buffer contains the information of each camera instance enumerated.<strong>If we don't care about that multiple cameras connect to the computer simultaneously, it's optional to call this function to enumerate the camera instances</strong>.</p>
    <p>The code snippet shows as below:<br/></p>
<table width="100%" border="0" bgcolor="#B0D0B0">
  <tr><td><pre>ToupcamInst arr[TOUPCAM_MAX];
unsigned cnt = Toupcam_Enum(arr);
for (unsigned i = 0; i &lt; cnt; ++i)
    ......</pre></td></tr>
</table><br/>
<table width="100%" border="0" bgcolor="#B0D0B0">
<tr><td><pre>typedef struct{
#ifdef _WIN32
    const wchar_t*     name;     /* model name */
#else
    const char*        name;
#endif
    unsigned           flag;     /* TOUPCAM_FLAG_xxx */
    unsigned           maxspeed; /* maximum speed level, Toupcam_get_MaxSpeed, the speed range = [0, maxspeed], closed interval */
    unsigned           preview;  /* number of preview resolution, Toupcam_get_ResolutionNumber */
    unsigned           still;    /* number of still resolution, Toupcam_get_StillResolutionNumber */
    ToupcamResolution  res[TOUPCAM_MAX];
}ToupcamModel;</pre></td></tr>
</table><br/>
<div align="center">
<table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
 <tr>
   <td width="8%" valign="top">name</td>
   <td colspan="2" valign="top">The name of this model</td>
   </tr>
 <tr>
   <td width="8%" rowspan="21" valign="top">flag</td>
   <td colspan="2" valign="top">Bitwise flag </td>
   </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CMOS</td>
   <td valign="top">cmos sensor</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CCD_PROGRESSIVE</td>
   <td valign="top">progressive ccd sensor</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_CCD_INTERLACED</td>
   <td valign="top">interlaced ccd sensor</td>
 </tr>
 <tr>
   <td valign="top">TOUPCAM_FLAG_ROI_HARDWARE</td>
   <td valign="top">support hardware ROI. Hardware ROI means only the ROI part of image is output from the sensor and the software cropping operation is not required. Higher frame rate is achieved when using hardware ROI method. Software ROI means the image with the complete field of view of the sensor will be output and software cropping operation is required to obtain the ROI image.</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_MONO</td>
   <td width="63%" valign="top">monochromatic sensor</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BINSKIP_SUPPORTED</td>
   <td width="63%" valign="top">support bin/skip mode, see Toupcam_put_Mode and Toupcam_get_Mode</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_USB30</td>
   <td width="63%" valign="top">USB 3.0</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_COOLED</td>
   <td width="63%" valign="top">Cooled</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_USB30_OVER_USB20</td>
   <td width="63%" valign="top">usb3.0 camera connected to usb2.0 port</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_ST4</td>
   <td width="63%" valign="top">ST4 port</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_GETTEMPERATURE</td>
   <td width="63%" valign="top">support to get the temperature of sensor, Toupcam_get_Temperature</td>
 </tr>
 <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_PUTTEMPERATURE</td>
   <td width="63%" valign="top">support to put the temperature of sensor, Toupcam_put_Temperature</td>
 </tr> 
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH10</td>
   <td width="63%" valign="top">Maximum Bit Depth = 10 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH12</td>
   <td width="63%" valign="top">Maximum Bit Depth = 12 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH14</td>
   <td width="63%" valign="top">Maximum Bit Depth = 14 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_BITDEPTH16</td>
   <td width="63%" valign="top">Maximum Bit Depth = 16 bits</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_FAN</td>
   <td width="63%" valign="top">cooling fan</td>
 </tr>
  <tr>
   <td width="29%" valign="top">TOUPCAM_FLAG_COOLERONOFF</td>
   <td width="63%" valign="top">cooler can be turn on or off</td>
 </tr>
  <tr>
    <td valign="top">TOUPCAM_FLAG_ISP</td>
    <td valign="top">image signal processing supported</td>
  </tr>
  <tr>
    <td valign="top">TOUPCAM_FLAG_TRIGGER</td>
    <td valign="top">support the trigger mode</td>
  </tr>
 <tr>
   <td width="8%" valign="top">maxspeed</td>
   <td colspan="2" valign="top">Maximum speed level, same with Toupcam_get_MaxSpeed. The speed range is [0, maxspeed]. see Toupcam_put_Speed and Toupcam_get_Speed</td>
   </tr>
 <tr>
   <td width="8%" valign="top">preview</td>
   <td colspan="2" valign="top">Number of preview resolution. Same with Toupcam_get_ResolutionNumber</td>
   </tr>
 <tr>
   <td width="8%" valign="top">still</td>
   <td colspan="2" valign="top">Number of still resolution, zero means still capture is not supported. Same with Toupcam_get_StillResolutionNumber</td>
   </tr>
  <tr>
   <td width="8%" valign="top">res</td>
   <td colspan="2" valign="top">Resolution, width and height</td>
   </tr>
</table>
</div>
</li></ul>
<ul><li><h2>Toupcam_HotPlug</h2>
  <p><strong>Return value:</strong> NA</p>
  <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>PTOUPCAM_HOTPLUG pHotPlugCallback: callback function</p>
    <blockquote>
    <table width="100%" border="0" bgcolor="#B0D0B0">
      <tr>
        <td><div align="center">typedef void (*PTOUPCAM_HOTPLUG)(void* pCallbackCtx);</div></td>
      </tr>
    </table>
  </blockquote>
    <p>void* pCallbackCtx: callback context</p>
  </blockquote>
  <p><strong>Remarks:</strong></p><blockquote>
  <p>This function is only available on OSX and Linux, it's unnecessary on Windows.</p>
  <p>To process the device plug in / pull out in Windows, please refer to the MSDN(<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363224(v=vs.85).aspx">Device Management</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363215(v=vs.85).aspx">Detecting Media Insertion or Removal</a>).</p>
  <p>To process the device plug in / pull out in Linux / OSX, please call this function to register the callback function. When the device is inserted or pulled out, you will be notified by the callback funcion, and then call Toupcam_Enum(...) again to enum the cameras.</p>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_Open</h2>
  <p><strong>Return value:</strong> HToupCam handle. Return NULL when fails (Such as the device has been pulled out).</p>
  <p><strong>Parameters:</strong></p>
  	<blockquote>
  		<p>id: ToupCam camera instance, enumerated by Toupcam_Enum. <strong>If id is NULL, Toupcam_Open will open the first camera which connects to the computer. So, if we don't care about that multiple cameras connect to the computer simultaneously, Toupcam_Enum is optional, we can simply use NULL as the parameter.</strong></p>
  	</blockquote>
  <p><strong>Remarks:</strong> open the camera instance.</p>
</li></ul>
<ul><li><h2>Toupcam_Close</h2>
    <p><strong>Return value:</strong> void</p>
    <p><strong>Parameters:</strong></p>
		<blockquote>
			<p>HToupCam h: camera instance handle</p>
		</blockquote>
    <p><strong>Remarks:</strong> close the camera instance. After it is closed, never use the HToupCam handle any more. <strong>Do not call Toupcam_Close in the PTOUPCAM_EVENT_CALLBACK and PTOUPCAM_DATA_CALLBACK callback function, otherwise, deadlock occurs.</strong></p>
</li></ul>
<ul><li><h2>Toupcam_StartPullModeWithWndMsg, Toupcam_StartPullModeWithCallback</h2>
    <p><strong>Return value:</strong> HRESULT type means "success/ failure"</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: instance handle opened by Toupcam_Open</p>
      <p>HWND hWnd: event occurs, message will be posted in this window</p>
      <p>UINT nMsg: Windows custom message type. Its WPARAM parameter means event type TOUPCAM_EVENT_xxxx, LPARAM is useless (always zero)</p>
      <p>PTOUPCAM_EVENT_CALLBACK pEventCallback, void* pCallbackContext: callback function specified by user's application and callback context parameter. This callback function is called back from the internal thread in toupcam.dll, so great attention should be paid to multithread issue. Do not call Toupcam_Stop and Toupcam_Close in this callback function, otherwise, deadlock occurs.</p>
        <table width="100%" border="0">
          <tr>
            <td bgcolor="#B0D0B0"><div align="center">typedef void (__stdcall* PTOUPCAM_EVENT_CALLBACK)(unsigned nEvent, void* pCallbackCtx);</div></td>
          </tr>
        </table>
      </blockquote>
    <p><strong>Remarks:</strong> Obviously, Toupcam_StartPullModeWithWndMsg is only supported in Windows OS.</p>
</li></ul>
<ul><li><h2>Toupcam_PullImage, Toupcam_PullStillImage</h2>
      <p><strong>Return value:</strong> HRESULT type means "success/ failure". Return E_FAIL when there isn't image ready for pull.</p>
      <p><strong>Parameters:</strong></p>
      <blockquote>
    <p>HToupCam h: instance handle opened by Toupcam_Open</p>
    <p>void* pImageData: Data buffer. Users have to make sure that the data buffer capacity is enough to save the image data.</p>
    <p>int bits: 24, 32, 48 or 8, means RGB24, RGB32, RGB48 or 8 bits grey images. This parameter is ignored in RAW mode.</p>
    <p>unsigned* pnWidth, unsigned* pnHeight: out parameter. width and height of image.</p>
</blockquote>
  <p><strong>Remarks:</strong> when pImageData is NULL, while pnWidth and pnHeight are not NULL, you can "peek" the width and height of images.</p>
  <p>Please ensure that the pImageData buffer is large enough to hold the entire frame data, see the table below:</p>
  <blockquote><div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td colspan="2" valign="top">Format</td>
        <td width="63%" valign="top">Buffer Size</td>
      </tr>
      <tr>
        <td width="10%" rowspan="4" valign="top">RGB</td>
        <td width="27%" valign="top">RGB24</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(24 * Width) * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB32</td>
        <td width="63%" valign="top">Width * Height * 4</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB48</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(48 * Width) * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">RGB8 grey image</td>
        <td width="63%" valign="top">DIBWIDTHBYTES(8 * Width) * Height</td>
      </tr>
      <tr>
        <td width="10%" rowspan="2" valign="top">RAW</td>
        <td width="27%" valign="top">8bits Mode</td>
        <td width="63%" valign="top">Width * Height</td>
      </tr>
      <tr>
        <td width="27%" valign="top">10bits, 12bits, 14bits, 16bits Mode</td>
        <td width="63%" valign="top">Width * Height * 2</td>
      </tr>
    </table>
  </div><br/>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr>
   <td>#ifndef DIBWIDTHBYTES<br/>
#define DIBWIDTHBYTES(bits) ((unsigned)(((bits) + 31) &amp; (~31)) / 8)<br/>
#endif<br/>
</td></tr>
</table></div></blockquote>
</li></ul>
<ul><li><h2>Toupcam_StartPushMode</h2>
    <p><strong>Return value:</strong> HRESULT type means "success / failure"</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: instance handle opened by Toupcam.</p>
      <p>Open PTOUPCAM_DATA_CALLBACK pDataCallback, void* pCallbackCtx: the callback function and callback context parameters that are specified by the user's program. Toupcam.dll gets image data from the camera, then calls back this function.</p>
    </blockquote>
  <blockquote>
    <table width="100%" border="0" bgcolor="#B0D0B0">
      <tr>
        <td><div align="center">typedef void (*PTOUPCAM_DATA_CALLBACK)(const void* pData, const BITMAPINFOHEADER* pHeader, BOOL bSnap, void* pCallbackCtx);</div></td>
      </tr>
    </table>
  </blockquote>
  <blockquote>
    <p align="left">when calls back, if Parameter pData == NULL, then internal error occurs (eg: the camera pulled out suddenly).<br/>
      For parameter BOOL bSnap, TRUE means still image snap by Toupcam_Snap function, FALSE means ordinary previewed pictures/ videos.<br/>
      Attention: this callback function is called back from the internal thread in toupcam.dll, so great attention should be paid to multithread issue. Do not call Toupcam_Stop and Toupcam_Close in this callback function, otherwise, deadlock occurs.</p>
  </blockquote>
  <p><strong>Remarks:</strong> start camera instance.</p>
</li></ul>
<ul><li><h2>Toupcam_Stop</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    	<blockquote>
    		<p>HToupCam handle</p>
    	</blockquote>
    <p><strong>Remarks:</strong> stop the camera instance. Do not call Toupcam_Stop in the PTOUPCAM_EVENT_CALLBACK and PTOUPCAM_DATA_CALLBACK callback function, otherwise, deadlock occurs. After stopped, it can be restart again. For example, switching the video resolution:   </p>
    <blockquote>
      <p>Step 1: call Toupcam_Stop to stop</p>
      <p>Step 2: call Toupcam_put_Size or Toupcam_put_eSize to set the new resolution</p>
      <p>Step 3: call Toupcam_StartPullModeWithWndMsg or Toupcam_StartPullModeWithCallback or Toupcam_StartPushMode to restart</p>
    </blockquote>
</li></ul>
<ul><li><h2>Toupcam_Pause</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    	<blockquote>
    		<p>HToupCam h: camera instance handle</p>
    	</blockquote>
    <p><strong>Remarks:</strong> pause/continue camera instance.</p>
</li></ul>
<ul><li><h2>Toupcam_Snap</h2>
  <p><strong>Return value:</strong> HRESULT type means success / failure</p>
  <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>unsigned nResolutionIndex: resolution index wanted.</p>
  </blockquote>
  <p><strong>Remarks:</strong> snap 'still' image. When snap successfully:</p>
  <blockquote><blockquote>
  <p>a) If we use Pull Mode, it will be notified by TOUPCAM_EVENT_STILLIMAGE.</p>
  <p>b) If we use Push Mode, the image will be returned by callback function PTOUPCAM_DATA_CALLBACK with the parameter BOOL bSnap is TRUE.</p>
	</blockquote>
    <p>Most cameras can snap still image with different resolutions under continuous preview. For example, UCMOS03100KPA's previewed resolution is 1024*768, if we call Toupcam_Snap(h, 0), we get so called "still image" with 2048*1536 resolution.<br/>
    Some cameras hasn't this ability, so nResolutionIndex must be equal the preview resolution which is set by Toupcam_put_Size, or Toupcam_put_eSize.<br/>
    Whether it supports "still snap" or not, see "still" domain in ToupcamModel.</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_Trigger</h2>
  <p><strong>Return value:</strong> HRESULT type means success / failure. If trigger mode is not supported, the return value is E_NOTIMPL.</p>
  <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
  </blockquote>
  <p><strong>Remarks:</strong> in trigger mode, call this function to trigger an image:</p>
  <blockquote>
  <p>a) If we use Pull Mode, it will be notified by TOUPCAM_EVENT_IMAGE.</p>
  <p>b) If we use Push Mode, the image will be returned by callback function PTOUPCAM_DATA_CALLBACK with the parameter BOOL bSnap is FALSE.</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_put_Size, Toupcam_get_Size, Toupcam_put_eSize, Toupcam_get_eSize</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned nResolutionIndex: current/present resolution index</p>
      <p>int nWidth, int nHeight: width and height of current resolution index</p>
    </blockquote>
  <p><strong>Remarks:</strong> set/get current resolution</p>
        <blockquote>
          <p align="left">Set resolution before running Toupcam_StartPullModeWithWndMsg or Toupcam_StartPullModeWithCallback or Toupcam_StartPushMode<br/>
            There are two ways to set current resolution: one is by resolution index, the other by width/height. Both ways are equivalent. For example, UCMOS03100KPA supports the following three kinds of resolution: <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Index 0: 2048, 1536<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Index 1: 1024, 768<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Index 2: 680, 510<br/>
            So Toupcam_put_Size(h, 1024, 768) is as effective as Toupcam_put_eSize(h, 1)</p>
        </blockquote>
</li></ul>
<ul><li><h2><a id="#roi">Toupcam_put_Roi, Toupcam_get_Roi</a></h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure.</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned xOffset: x offset, must be even number</p>
      <p>unsigned yOffset: y offset, must be even number</p>
      <p>unsigned xWidth: width, must be even number and must not be less than 16</p>
      <p>unsigned yHeight: height, must be even number and must not be less than 16</p>
    </blockquote>
  <p><strong>Remarks:</strong> set/get the ROI. Toupcam_put_Roi(h, 0, 0, 0, 0) means to clear the ROI and restore the original size.</p>
  <blockquote>
  	The second resolution of UHCCD03100KPB, UHCCD05000KPA, UHCCD05100KPA don't support ROI, so the return value is E_NOTIMPL.
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_get_ResolutionNumber, Toupcam_get_Resolution</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned nIndex: resolution index</p>
      <p>int* pWidth, int* pHeight: width/height</p>
    </blockquote>
    <p><strong>Remarks:</strong> Toupcam_get_ResolutionNumber means the number of resolution supported. Take UCMOS03100KPA as an example, if we call the function Toupcam_get_ResolutionNumber and get "3", which means it can support three kinds of resolution. Toupcam_get_Resolution obtains the width/height of each kind of resolution.</p>
  <blockquote>
    <p align="left">These parameters have also been contained in ToupcamModel.</p>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_get_RawFormat</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>unsigned* nFourCC: raw format, see the table below</p>
    <p>unsigned* bitdepth: Bit Depth, such as 8, 12, 14, 16</p>
<div align="center"><table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr>
   <td>#ifndef MAKEFOURCC<br/>
#define MAKEFOURCC(a, b, c, d) ((uint32_t)(uint8_t)(a) | ((uint32_t)(uint8_t)(b) &lt;&lt; 8) | ((uint32_t)(uint8_t)(c) &lt;&lt; 16) | ((uint32_t)(uint8_t)(d) &lt;&lt; 24))<br/>
#endif<br/></td>
  </tr>
</table></div><br/>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('G', 'B', 'R', 'G')</td>
        <td width="60%" valign="top">GBGBGB...<br/>RGRGRG...<br/>GBGBGB...<br/>RGRGRG...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('R', 'G', 'G', 'B')</td>
        <td width="60%" valign="top">RGRGRG...<br/>GBGBGB...<br/>RGRGRG...<br/>GBGBGB...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('B', 'G', 'G', 'R')</td>
        <td width="60%" valign="top">BGBGBG...<br/>GRGRGR...<br/>BGBGBG...<br/>GRGRGR...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('G', 'R', 'B', 'G')</td>
        <td width="60%" valign="top">GRGRGR...<br/>BGBGBG...<br/>GRGRGR...<br/>BGBGBG...<br/>...<br/></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('Y', 'U', 'Y', 'V')</td>
        <td width="60%" valign="top">YUV4:2:2, please see: <a href="http://www.fourcc.org">http://www.fourcc.org</a></td>
      </tr>
      <tr>
        <td width="40%" valign="top">MAKEFOURCC('Y', 'Y', 'Y', 'Y')</td>
        <td width="60%" valign="top">Black / White camera</td>
      </tr>      
    </table>
  </div>
  </blockquote>
</li></ul>
<ul><li><h2>Toupcam_put_Option, Toupcam_get_Option</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>unsigned iOption: see the table</p>
    <p>unsigned iValue: see the table</p>
  <div align="center">
    <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
    <tr>
    	<td width="28%">Option</td>
    	<td width="48%">Description</td>
    	<td width="4%">Default</td>
    	<td width="20%">The value can be changed after Toupcam_StartPullModeWithWndMsg or Toupcam_StartPullModeWithCallback or Toupcam_StartPushMode?</td>
	</tr>
      <tr>
        <td width="28%">TOUPCAM_OPTION_NOFRAME_TIMEOUT</td>
        <td width="48%">Report error if cannot grab frame in a certain time.<br/>
          1 = enable this feature;<br/>0 = disable this feature.</td>
        <td width="4%">1</td>
        <td width="20%">Yes</td>
      </tr>
      <tr>
        <td width="28%">TOUPCAM_OPTION_THREAD_PRIORITY</td>
        <td width="48%">set the priority of the internal thread which grab data from the usb device.<br/>
          0 = THREAD_PRIORITY_NORMAL;<br/>1 = THREAD_PRIORITY_ABOVE_NORMAL;<br/>2 = THREAD_PRIORITY_HIGHEST;<br/>Please refer to <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686277(v=vs.85).aspx">SetThreadPriority</a><br/>This option is not available at Linux and OSX.</td>
        <td width="4%">0</td>
        <td width="20%">Yes</td>
      </tr>
      <tr>
        <td width="28%">TOUPCAM_OPTION_PROCESSMODE</td>
        <td width="48%">0 = better image quality, more cpu usage.<br/>
          1 = lower image quality, less cpu usage.</td>
        <td width="4%">0</td>
        <td width="20%">Yes</td>
      </tr>
      <tr>
        <td width="28%"><a id="rawo">TOUPCAM_OPTION_RAW</a></td>
        <td width="48%">0 means RGB mode.<br/>
          1 means RAW mode, read the CMOS or CCD raw data.</td>
        <td width="4%">0</td>
        <td width="20%">No<br/>
          (The return value is E_UNEXPECTED when set this option after the camera is started)</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_BITDEPTH</td>
      	<td width="48%">Some cameras support the bit depth which is more than 8 such as 10, 12, 14, 16.<br/>
      	  0 = use 8 bits depth.<br/>1 = use the maximum bits depth of this camera.</td>
      	<td width="4%">NA</td>
      	<td width="20%">Yes</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_FAN</td>
      	<td width="48%">Some cameras support the cooling fan.<br/>
      	  0 = turn off the cooling fan<br/>1 = turn on the cooling fan</td>
      	<td width="4%">1</td>
      	<td width="20%">Yes</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_COOLER</td>
      	<td width="48%">Some cameras support to turn on or off the cooler.<br/>
      	  0 = turn off cooler<br/>1 = turn on cooler</td>
      	<td width="4%">1</td>
      	<td width="20%">Yes</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_LINEAR</td>
      	<td width="48%">0 = turn off linear tone mapping<br/>
      	  1 = turn on linear tone mapping</td>
      	<td width="4%">1</td>
      	<td width="20%">Yes</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_CURVE</td>
      	<td width="48%">0 = turn off curve tone mapping<br/>
      	  1 = turn on curve tone mapping</td>
      	<td width="4%">1</td>
      	<td width="20%">Yes</td>
      </tr>
      <tr>
      	<td width="28%">TOUPCAM_OPTION_TRIGGER</td>
      	<td width="48%">0 = continuous mode<br/>
      	  1 = trigger mode</td>
      	<td width="4%">0</td>
      	<td width="20%">No<br/>
      	  (The return value is E_UNEXPECTED when set this option after the camera is started)</td>
      </tr>
      <tr>
      	<td width="28%"><a id="#rgb48">TOUPCAM_OPTION_RGB48</a></td>
      	<td width="48%">enable RGB48 format when bitdepth > 8</td>
      	<td width="4%">0</td>
      	<td width="20%">No<br/>
      	  (The return value is E_UNEXPECTED when set this option after the camera is started)</td>
      </tr>      
    </table>
  </div>
  </blockquote>
<blockquote>
  <p>In general, you do not need to set the value of these options. If you do want to set these options, please ensure that you understand their specific meanings.</p>
  <p>The second resolution of UHCCD03100KPB, UHCCD05000KPA, UHCCD05100KPA don't support RAW mode.</p>
</blockquote>
</li></ul>
<ul><li><h2>Toupcam_put_RealTime, Toupcam_get_RealTime</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>BOOL bEnable: TRUE or FALSE</p>
    </blockquote>
    <p><strong>Remarks:</strong> If you set RealTime mode as TRUE, then you get shorter frame delay but lower frame rate which damages fluency. The default value is FALSE.</p>
</li></ul>
<ul><li><h2>Toupcam_get_AutoExpoEnable, Toupcam_put_AutoExpoEnable, Toupcam_get_AutoExpoTarget, Toupcam_put_AutoExpoTarget, Toupcam_put_MaxAutoExpoTimeAGain</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>BOOL bAutoExposure: TRUE or FALSE</p>
      <p>unsigned short Target: auto-exposure target</p>
      <p>unsigned maxTime, unsigned short maxAGain: the maximum time and maximum analog gain of auto-exposure</p>
    </blockquote>
    <p><strong>Remarks:</strong> If auto exposure is enabled, the exposure time and analog gain are controlled by software to make the average brightness of the target rectangle as close as possible to the auto exposure target. The auto exposure target value is the target brightness of the target rectangle (see Toupcam_put_AEAuxRect, Toupcam_get_AEAuxRect).</p>
</li></ul>
<ul><li><h2>Toupcam_get_ExpoTime, Toupcam_put_ExpoTime, Toupcam_get_ExpTimeRange</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned Time: exposure time, unit: microsecond</p>
      <p>unsigned* nMin, unsigned* nMax, unsigned* nDef: the minimum, maximum and default value of exposure time.</p>
    </blockquote>
  <p><strong>Remarks:</strong> exposure time related.</p>
</li></ul>
<ul><li><h2>Toupcam_get_ExpoAGain, Toupcam_put_ExpoAGain, Toupcam_get_ExpoAGainRange</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned short AGain: analog gain, shown in percentage, eg, 200 means the analog gain is 200%</p>
      <p>unsigned short* nMin, unsigned short* nMax, unsigned short* nDef: the minimum, maximum and default value of analog gain.</p>
    </blockquote>
  <p><strong>Remarks:</strong> analog gain related.</p>
</li></ul>
<ul><li><h2>Toupcam_put_Hue, Toupcam_get_Hue, Toupcam_put_Saturation, Toupcam_get_Saturation, Toupcam_put_Brightness, Toupcam_get_Brightness, Toupcam_get_Contrast, Toupcam_put_Contrast, Toupcam_get_Gamma, Toupcam_put_Gamma</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
    	<p>HToupCam h: camera instance handle</p>
    </blockquote>
    <p><strong>Remarks:</strong> set or obtain hue, saturation, brightness, contrast and gamma.</p>
</li></ul>
<ul><li><h2>Toupcam_get_Chrome, Toupcam_put_Chrome</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>BOOL bChrome: TRUE or FALSE</p>
    </blockquote>
    <p><strong>Remarks:</strong> color or gray mode</p>
</li></ul>
<ul><li><h2>Toupcam_get_VFlip, Toupcam_put_VFlip, Toupcam_get_HFlip, Toupcam_put_HFlip</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong> HToupCam h: camera instance handle</p>
      <p><strong>Remarks:</strong> vertical/horizontal flip.</p>
</li></ul>
<ul><li><h2>Toupcam_put_Speed, Toupcam_get_Speed, Toupcam_get_MaxSpeed</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned short nSpeed: frame rate level</p>
    </blockquote>
    <p><strong>Remarks:</strong> the minimum frame rate level is "0", the maximum one can be achieved through Function "Toupcam_get_MaxSpeed" which equals to maxspeed in ToupcamModel.</p>
</li></ul>
<ul><li><h2>Toupcam_put_HZ, Toupcam_get_HZ</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>int nHZ: 0: 60Hz alternating current, 1: 50Hz alternating current, 2: direct current</p>
    </blockquote>
    <p><strong>Remarks:</strong> set the light source power frequency</p>
</li></ul>
<ul><li><h2>Toupcam_get_Temperature, Toupcam_put_Temperature</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure, E_NOTIMPL means not supporting get / set the temperature</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>short nTemperature: in 0.1 degrees Celsius (32 means 3.2 degrees Celsius).</p>
    </blockquote>
    <p><strong>Remarks:</strong> get / set the temperature of sensor. see TOUPCAM_FLAG_GETTEMPERATURE and TOUPCAM_FLAG_PUTTEMPERATURE.</p>
</li></ul>
<ul><li><h2>Toupcam_put_Mode, Toupcam_get_Mode</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>BOOL bSkip: Bin mode or Skip mode.</p>
  </blockquote>
  <p><strong>Remarks:</strong> set Bin mode or Skip mode. Cameras with higher resolution can support two sampling modes, one is Bin mode (Neighborhood averaging), the other is Skip (sampling extraction). In comparison, the former is with better image effect but decreasing frame rate while the latter is just the reverse.</p>
</li></ul>
<ul><li><h2>Toupcam_put_TempTint, Toupcam_get_TempTint</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure. Works int Temp/Tint mode. Does not work int RGB Gain mode, E_NOTIMPL will be return.</p>
      <p><strong>Parameters:</strong></p>
    <blockquote>
    	<p>HToupCam h: camera instance handle</p>
    	<p>int nTemp, int nTint: color temperature and Tint</p>
	</blockquote>
  <p><strong>Remarks:</strong> set/obtain the color temperature and Tint parameters of white balance (Temp/Tint Mode, please see <a href="#wb">here</a>).</p>
</li></ul>
<ul><li><h2>Toupcam_AwbOnePush </h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure. Works int Temp/Tint mode. Does not work int RGB Gain mode, E_NOTIMPL will be return.</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>PITOUPCAM_TEMPTINT_CALLBACK fnTTProc, void* pTTCtx: callback function and callback context when the automatic white balance completes.</p>
    </blockquote>
    <p><strong>Remarks:</strong> Call this function to perform one "auto white balance" in Temp/Tint Mode. When the "auto white balance" completes, TOUPCAM_EVENT_TEMPTINT event notify the application (In Pull Mode) and callback happens. In pull mode, this callback is useless, set it to NULL.</p>
</li></ul>
<ul><li><h2>Toupcam_put_WhiteBalanceGain, Toupcam_get_WhiteBalanceGain</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure. Works int RGB Gain mode. Does not work int Temp/Tint Gain mode, E_NOTIMPL will be return.</p>
      <p><strong>Parameters:</strong></p>
    <blockquote>
    	<p>HToupCam h: camera instance handle</p>
    	<p>int aGain[3]: RGB Gain</p>
	</blockquote>
  <p><strong>Remarks:</strong> set/obtain the RGB gain parameters of white balance (RGB Gain Mode, please see <a href="#wb">here</a>).</p>
</li></ul>
<ul><li><h2>Toupcam_AwbInit</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure. Works int RGB Gain mode. Does not work int Temp/Tint mode, E_NOTIMPL will be return.</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>PITOUPCAM_WHITEBALANCE_CALLBACK fnWBProc, void* pWBCtx: callback function and callback context when the automatic white balance completes.</p>
    </blockquote>
    <p><strong>Remarks:</strong> Call this function to perform one "auto white balance" in RGB Gain Mode. When the "auto white balance" completes, TOUPCAM_EVENT_WBGAIN event notify the application (In Pull Mode) and callback happens. In pull mode, this callback is useless, set it to NULL.</p>
</li></ul>
<ul><li><h2>Toupcam_put_AWBAuxRect, Toupcam_get_AWBAuxRect, Toupcam_put_AEAuxRect, Toupcam_get_AEAuxRect</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
      <blockquote>
      	<p>HToupCam h: camera instance handle</p>
      </blockquote>
      <p><strong>Remarks:</strong> set/obtain the ROI (Rectangle of Interest) of automatic white balance and auto-exposure. The default ROI is in the center of the image, its width is 20% image with, its height is 20% image height.</p>
  </li>
</ul>
<ul><li><h2>Toupcam_get_MonoMode</h2>
    <p><strong>Return value:</strong> S_OK means mono mode, S_FALSE means color mode</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
    	<p>ToupCam h: camera instance handle</p>
    </blockquote>
    <p><strong>Remarks:</strong> gray camera or not, find the flag in ToupCamModel: TOUPCAM_FLAG_MONO</p>
</li></ul>
<ul><li><h2>Toupcam_get_MaxBitDepth</h2>
    <p><strong>Return value:</strong> the maximum bit depth this camera supports.</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
    	<p>HToupCam h: camera instance handle</p>
    </blockquote>
    <p><strong>Remarks:</strong> Some cameras support the bit depth which is more than 8 such as 10, 12, 14, 16.</p>
</li></ul>
<ul><li>
    <h2>Toupcam_get_StillResolutionNumber, Toupcam_get_StillResolution</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned nIndex: resolution index</p>
      <p>int* pWidth, int* pHeight: width/height</p>
    </blockquote>
    <p><strong>Remarks:</strong> Toupcam_get_StillResolutionNumber means the number of supported still resolution. Take UCMOS03100KPA as an example, if we call the function Toupcam_get_StillResolutionNumber and get "3", which means it can support three kinds of resolution. If it doesn't support "still snap", then we get "0". Toupcam_get_Resolution obtains the width/height of each kind of resolution.</p>
</li></ul>
<ul><li>
    <h2>Toupcam_get_SerialNumber, Toupcam_get_FwVersion, Toupcam_get_HwVersion, Toupcam_get_ProductionDate</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>char sn[32]: buffer to the serial number, such as: TP110826145730ABCD1234FEDC56787</p>
    <p>char fwver[16]: buffer to the firmware version, such as: 3.2.1.20140922</p>
    <p>char hwver[16]: buffer to the hardware version, such as: 3.2.1.20140922</p>
    <p>char pdate[10]: buffer to the production date, such as: 20150327</p>
  </blockquote>
  <p><strong>Remarks:</strong> each camera has a unique serial number with 31 letters, eg,"TP110826145730ABCD1234FEDC56787"</p>
</li></ul>  
<ul><li>
    <h2>Toupcam_put_LEDState</h2>
  <p><strong>Return value:</strong> HRESULT type means success / failure</p>
  <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>unsigned short iLed: the index of LED light</p>
    <p>unsigned short iState: LED status, 1 -&gt; Ever bright; 2 -&gt; Flashing; other -&gt; Off</p>
    <p>unsigned short iPeriod: Flashing Period (&gt;= 500ms)</p>
  </blockquote>
  <p><strong>Remarks:</strong> One or more LED lights installed on some camera. This function controls the status of these lights.</p>
</li></ul>
<ul><li><h2>Toupcam_read_EEPROM, Toupcam_write_EEPROM</h2>
  <p><strong>Return value:</strong> HRESULT type means failure or byte(s) transferred</p>
  <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>unsigned addr: EEPROM address</p>
    <p>const unsigned char* pData: data to be written</p>
    <p>unsigned char* pBuffer: read EEPROM to buffer</p>
    <p>unsigned nDataLen: data length to be written</p>
    <p>unsigned nBufferLen: buffer length to read</p>
  </blockquote>
  <p><strong>Remarks:</strong> In some cameras, EEPROM is available for read and write. If failed to read or write, a negative HRESULT error code will be return, when success, the bytes number has been read or written will be return.</p>
</li></ul>
<ul><li><h2>Toupcam_put_ExpoCallback</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>PITOUPCAM_EXPOSURE_CALLBACK fnExpoProc, void* pExpoCtx: exposure callback function and callback context. If we set fnExpoProc as NULL, then it means stop calling back.</p>
  </blockquote>
  <p><strong>Remarks:</strong> Once we set non-NULL callback function, then callback happens whenever the exposure time changes.</p>
</li></ul>
<ul><li><h2>Toupcam_put_ChromeCallback</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>PITOUPCAM_CHROME_CALLBACK fnChromeProc, void* pChromeCtx: color/gray switches callback function and callback context. If we set fnChromeProc as NULL, then it means stop calling back.</p>
  </blockquote>
  <p><strong>Remarks:</strong> once we set non-NULL callback function, then callback happens whenever the color/gray switches, eg, call Toupcam_put_Chrome</p>
</li></ul>
<ul><li><h2>Toupcam_LevelRangeAuto</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
      <blockquote>
      	<p>HToupCam h: camera instance handle</p>
      </blockquote>
      <p><strong>Remarks:</strong> auto Level Range.</p>
</li></ul>
<ul><li><h2>Toupcam_put_LevelRange, Toupcam_get_LevelRange</h2>
    <p><strong>Return value:</strong> HRESULT type means success / failure</p>
    <p><strong>Parameters:</strong></p>
    <blockquote>
      <p>HToupCam h: camera instance handle</p>
      <p>unsigned short aLow[4], unsigned short aHigh[4]: Level Range of R, G, B, and Gray. RGB is only available for color image, and gray is only available for gray image.</p>
    </blockquote>
    <p><strong>Remarks:</strong> level range related.</p>
</li></ul>
<ul><li><h2>Toupcam_GetHistogram</h2>
      <p><strong>Return value:</strong> HRESULT type means success / failure</p>
      <p><strong>Parameters:</strong></p>
  <blockquote>
    <p>HToupCam h: camera instance handle</p>
    <p>PITOUPCAM_HISTOGRAM_CALLBACK fnHistogramProc, void* pHistogramCtx: callback function and callback context of histogram data.</p>
  </blockquote>
  <p><strong>Remarks:</strong> obtain histogram data.</p>
</li></ul>
<hr/>
<h1><font color="#0000FF">5. .NET and C# and VB.NET</font></h1>
<hr/>
<p>Toupcam does support .NET development environment (C# and VB.NET).</p>
<p>toupcam.cs in the 'inc' directory use P/Invoke call into toupcam.dll. Copy toupcam.cs to your C# project, please reference toupcamdemowinformcs1 and toupcamdemowinformcs2 in the samples directory.</p>
<p>The C# class ToupTek.ToupCam is a thin wrapper class of the native C/C++ API of toupcam.dll, it's properties and methods P/Invoke into the corresponding Toupcam_xxxx functions of toupcam.dll. So, the descriptions of the Toupcam_xxxx function are also applicable for the corresponding C# properties or methods. For example, the C# Snap method call the function Toupcam_Snap, the descriptions of the Toupcam_Snap function is applicable for C# Snap method:</p>
<table width="100%" border="0" bgcolor="#B0D0B0">
<tr><td><pre>[DllImport(&quot;toupcam.dll&quot;, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
private static extern int Toupcam_Snap(SafeHToupCamHandle h, uint nResolutionIndex);

public bool Snap(uint nResolutionIndex)
{
    if (_handle == null || _handle.IsInvalid || _handle.IsClosed)
        return false;
    return (Toupcam_Snap(_handle, nResolutionIndex) &gt;= 0);
}</pre></td></tr></table>
<p>VB.NET is similar with C#, not otherwise specified.</p>
<hr/>
<h1><font color="#0000FF">6. Others</font></h1>
<hr/>
<ul>
  <li>Byte order (BGR vs RGB)
    <blockquote>
      <p>Windows: BGR</p>
      <p>OSX, Linux: RGB</p>
    </blockquote>
  </li>
</ul>
<ul>
  <li>Ranges and default value of some parameters</li>
</ul>
<blockquote>
<div align="center">
 <table width="100%" border="1" cellpadding="0" cellspacing="0" bgcolor="#B0D0B0">
  <tr>
    <td colspan="3">Parameters</td>
    <td width="11%">Range</td>
    <td width="8%">Default value</td>
    <td width="17%">Get</td>
    <td width="17%">Set</td>
    <td width="14%">Auto</td>
  </tr>
  <tr>
    <td colspan="3">Auto Exposure Target</td>
    <td width="11%">16~235</td>
    <td width="8%">120</td>
    <td width="17%">Toupcam_get_AutoExpoTarget</td>
    <td width="17%">Toupcam_put_AutoExpoTarget</td>
    <td width="14%">&nbsp;</td>
  </tr>
  <tr>
    <td width="14%" rowspan="5">White Balance</td>
    <td width="9%" rowspan="2">Temp/Tint Mode</td>
    <td width="10%">Color Temperature</td>
    <td width="11%">2000~15000</td>
    <td width="8%">6503</td>
    <td width="17%" rowspan="2">Toupcam_get_TempTint</td>
    <td width="17%" rowspan="2">Toupcam_put_TempTint</td>
    <td width="14%" rowspan="2">Toupcam_AwbOnePush</td>
  </tr>
  <tr>
    <td width="10%">Tint</td>
    <td width="11%">200~2500</td>
    <td width="8%">1000</td>
    </tr>
  <tr>
    <td rowspan="3">RGB Gain Mode</td>
    <td>Red Gain</td>
    <td rowspan="3">-128~128</td>
    <td rowspan="3">0</td>
    <td rowspan="3">Toupcam_get_WhiteBalanceGain</td>
    <td rowspan="3">Toupcam_put_WhiteBalanceGain</td>
    <td rowspan="3">Toupcam_AwbInit</td>
  </tr>
  <tr>
    <td>Green Gain</td>
    </tr>
  <tr>
    <td>Blue Gain</td>
    </tr>
  <tr>
    <td colspan="3">LevelRange</td>
    <td width="11%">0~255</td>
    <td width="8%">Low = 0<br/>
      High = 255</td>
    <td width="17%">Toupcam_get_LevelRange</td>
    <td width="17%">Toupcam_put_LevelRange</td>
    <td width="14%">Toupcam_LevelRangeAuto</td>
  </tr>
  <tr>
    <td colspan="3">Contrast</td>
    <td width="11%">-100~100</td>
    <td width="8%">0</td>
    <td width="17%">Toupcam_get_Contrast</td>
    <td width="17%">Toupcam_put_Contrast</td>
    <td width="14%">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="3">Hue</td>
    <td width="11%">-180~180</td>
    <td width="8%">0</td>
    <td width="17%">Toupcam_get_Hue</td>
    <td width="17%">Toupcam_put_Hue</td>
    <td width="14%">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="3">Saturation</td>
    <td width="11%">0~255</td>
    <td width="8%">128</td>
    <td width="17%">Toupcam_get_Saturation</td>
    <td width="17%">Toupcam_put_Saturation</td>
    <td width="14%">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="3">Brightness</td>
    <td width="11%">-64~64</td>
    <td width="8%">0</td>
    <td width="17%">Toupcam_get_Brightness</td>
    <td width="17%">Toupcam_put_Brightness</td>
    <td width="14%">&nbsp;</td>
  </tr>
  <tr>
    <td colspan="3">Gamma</td>
    <td width="11%">20~180</td>
    <td width="8%">100</td>
    <td width="17%">Toupcam_get_Gamma</td>
    <td width="17%">Toupcam_put_Gamma</td>
    <td width="14%">&nbsp;</td>
  </tr>
 </table>
</div>
</blockquote>
<ul>
  <li>Platform
    <ul>
      <li>Windows: CPU supports SSE2 instruction set or above
        <blockquote>
          <p>x86: XP SP3 or above</p>
          <p>x64: Win7 or above</p>
        </blockquote>
      </li>
      <li>OSX: x64; 10.7 or above</li>
      <li>Linux: CPU supports SSE3 instruction set or above; kernel 2.6.27 or above. (kernel 2.6.27 is released in October 2008)
        <blockquote>
          <p>x86: GLIBC 2.9 or above. (GLIBC 2.9 is released in November 2008)</p>
          <p>x64: GLIBC 2.14 or above. (GLIBC 2.14 is released in June 2011)</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>
<hr/>
<h1><font color="#0000FF">7. Changelog</font></h1>
<hr/>
<p>v1.6: support RGB48 when bit depth > 8, please see <a href="#rgb48">here</a></p>
<p>v1.5: support trigger mode</p>
<p>v1.4: White Balance: Temp/Tint Mode vs RGB Gain Mode, please see <a href="#wb">here</a></p>
<p>v1.3: ROI (Region Of Interest) supported: please see <a href="#roi">here</a></p>
<p>v1.2: more bit depth supported: 10bits, 12bits, 14bits, 16bits</p>
<p>v1.1: support RAW format, please see <a href="#raw">here</a> and <a href="#rawo">here</a>; support Linux and OSX</p>
<p>v1.0: initial release</p>
<hr/>
<h1><font color="#0000FF">8. Contact</font></h1>
<hr/>
<p>If you have any problems in using this SDK, please use the following information to contact us.<br/>
 www: <a href="http://www.touptek.com">www.touptek.com</a><br/>
 email: support@touptek.com</p>
</body>
</html>
